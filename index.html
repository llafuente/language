<!DOCTYPE html>
<html lang="en" id="top">
<head>
  <meta charset="utf-8">
  <meta http-equiv="cleartype" content="on" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width,minimum-scale=1.0,initial-scale=1,user-scalable=yes">

  <title>Plee</title>

  <style>

  pre, code, blockquote {
    background: none repeat scroll 0 0 rgba(1, 1, 1, 0.1);
    border: 1px solid #808080;
    border-radius: 4px;
    padding: 1px 2px;
    font-family: monospace;
    white-space: pre;
    word-break: normal;
    word-wrap: normal;
    width: 100%;
  }
  pre {
    padding: 8px;
  }
  pre code {
    border: 0;
    background: none;
  }
  * {
    color: #222;
  }
  strong, th {
    color: #000;
  }
  h1, h2, h3, h4, h5 {
    color: #cb3837;
  }
  body {
    max-width: 1000px;
    margin: 0 auto;
  }
  </style>
</head>
<body class="markdown-body">
    <section>
<h1 id="plee-language"> plee language</h1>
<p>What are you going to find here...
Plee language documentation and compiler implementation notes.</p>
<section>
<h2 id="breaf-introduction">1 Breaf introduction</h2>
<p>Things that the compiler <em>will do</em> for you.</p>
<ul>
<li><p>Testing - continuous integration (CI) and code coverage
at compile time.</p>
</li>
<li><p>Documentation. Plee has type inference so we need a way to export
that information, we build a basic documentation.</p>
</li>
<li><p>Export module interface in a clean file.
Something like header file in c.</p>
</li>
<li><p>Benchmarks.</p>
</li>
<li><p>Code expansion and beautifier. Plee is full of shortcuts that
generate code, code expansion display the full code that will be
executed.</p>
</li>
<li><p>Powerfull type introspection.</p>
</li>
</ul>
<p>Things that you should now before the <em>shocking news</em>.</p>
<ul>
<li><p>No classes hierarchy. plee propose modules as replacement.
Also, do not expect <code>this</code> as reserved word...</p>
</li>
<li><p>Auto scope. A variable use <code>function scope</code> or <code>block scope</code> automatically.</p>
</li>
<li><p>Robust memory management, focus on no leaks a proper error display
for easy debugging.</p>
</li>
<li><p>Curly braces are mandatory <em>everywhere</em> but you can avoid using parenthesis :)</p>
</li>
<li><p><em>pass-by-reference</em> everything to improve performance. You can clone
everything easily.</p>
</li>
<li><p>No uppercases. Everything is lowercased and <em>case sensitive</em>.
<em>False</em> is not <em>false</em>.</p>
</li>
<li><p>Every type has a <code>null</code> value.</p>
</li>
<li><p>Lazy typed (mix between dynamically typed and strong typed)</p>
</li>
<li><p>Comments are part of the language, cannot be everywhere,
only at statement level.</p>
</li>
</ul>
</section>
<section>
<h2 id="philosophy-behind-the-language">2 Philosophy behind the language</h2>
<ul>
<li><p>Error prone. If something is powerful but introduce errors,
need to be reconsidered at least.</p>
</li>
<li><p>Easy to learn. You will see many reserved words,
mostly because clarify things.</p>
</li>
<li><p>Easy to code &amp; be lazy.</p>
</li>
<li><p>Readability &amp; version control friendly.</p>
</li>
<li><p>Powerfull extensive core.</p>
</li>
<li><p>No hierarchy (Object Oriented programming).
Forget interfaces, abstract classes, protected methods, extends... Just plain and simple objects.</p>
</li>
<li><p>Be nice target for other languages. There is much code out there,
playing nice with other languages it&#39;s important to us.s</p>
</li>
</ul>
</section>
<section>
<h2 id="hello-world-example">3 Hello world example</h2>
<p>As every language, here is the <code>hello world</code>.</p>
<p>file: hello-world.plee</p>
<pre><code>log &quot;Hello world&quot;;
</code></pre><p>Execution from terminal</p>
<pre><code class="lang-bash">plee -e hello-world.plee #direct execution
</code></pre>
</section>
<section>
<h2 id="compiler">4 compiler</h2>
<section>
<h3 id="compiler-command-line">4.1 compiler command line</h3>
<p>Usage:</p>
<pre><code>plee [actions] file

actions:
  -e              execute
  -t              run tests
  -c              compile (default if no action sent)
  -p              parse

actions can be mixed
example: plee -e -c file.plee
execute and compile.

test arguments
-r path
--report path     path to save the report
-cv
--code-coverage

compile arguments

execute arguments

parse arguments
--cache          path to cache
--no-cache       disable cache
</code></pre></section>
<section>
<h3 id="parser-implementation-">4.2 Parser implementation.</h3>
<p>There are many languages out there that can solve many problems.
Plee want to be target of many languages to do so. We need to build the
compiler in layers, even if it&#39;s not optional, parse time vs compile time
is so huge that parser, could be not optimal but feature rich.</p>
<p>Each step exports JSON that could feed the next step.</p>
<p>Steps:</p>
<ul>
<li><p>Tokenizer.</p>
<p>Tokenize the code with the language rules (like <code>var a-b;</code> a-b is a variable not a, -, b)</p>
</li>
<li><p>AST generator ~&amp; Preprocesor</p>
<p>Transform the tokenizer output into full AST.</p>
</li>
<li><p>AST expansion</p>
<p>Reduce AST to it&#39;s minimal form. Undo the shortcuts found in the language.</p>
</li>
<li><p>Postprocesor</p>
<p>User defined rules.</p>
</li>
<li><p>Generate Target code from AST</p>
<p>This is the key to be <code>language target</code>. Also</p>
<p>Output: text files?</p>
</li>
</ul>
<p>And then... compile/execute.</p>
</section>
<section>
<h3 id="compiler-implementation">4.3 Compiler implementation</h3>
<p><strong>Study</strong> choose!</p>
<ul>
<li><p>Transcompile to C</p>
<p>fast, portable, rather straight. Some features are not supported (defer/lambda)
need to hack a lot the language</p>
</li>
<li><p>c bytecode</p>
<p>slow, portable, easy REPL</p>
</li>
<li><p>LLVM</p>
<p>very fast, difficult, nice linking to other languages like c/c++</p>
</li>
<li><p>JIT LLVM</p>
<p>rather fast, could support more introspection types,
more dynamic typing, easy REPL</p>
</li>
<li><p>AOT-JIT.</p>
<p>Use a JIT engine as Ahead of time compilation.</p>
</li>
</ul>
</section>
<section>
<h3 id="compile-time-execution-">4.4 compile-time execution.</h3>
<p>Some features of the language need compile-time execution,
like <code>test</code> or <code>bench</code>.</p>
</section>
<section>
<h3 id="libraries">4.5 libraries</h3>
<ul>
<li><p><a href="http://www.pcre.org/">pcre</a></p>
<p>Perl Compatible Regular Expressions</p>
</li>
<li><p><a href="http://www.pcre.org/">libuv</a></p>
<p>Asynchronous IO, NET, DNS &amp; threads tools.</p>
</li>
<li><p><a href="http://llvm.org/">llvm</a></p>
<p>Low Level Virtual Machine.</p>
<p>Compiler, AOC and JIT.</p>
</li>
</ul>
</section>
<section>
<h3 id="compilers-based-on-llvm">4.6 compilers based on LLVM</h3>
<ul>
<li><a href="https://bitbucket.org/kssreeram/clay">clay</a></li>
<li><a href="http://llvm.org/docs/tutorial/LangImpl1.html">kaleidoscope</a></li>
<li><a href="https://github.com/rust-lang/rust">rust</a></li>
<li><a href="https://github.com/weyrick/roadsend-php-raven">roadsend-php-raven</a></li>
<li><p><a href="https://code.google.com/p/unladen-swallow/wiki/RelevantPapers">unladen-swallow (phyton)</a></p>
</li>
<li><p><a href="http://llvm.lyngvig.org/Articles/Mapping-High-Level-Constructs-to-LLVM-IR">Mapping-High-Level-Constructs-to-LLVM-IR</a></p>
</li>
</ul>
</section>
<section>
<h3 id="general-purpose-vm">4.7 general purpose vm</h3>
<ul>
<li><a href="http://www.parrot.org">parrot</a> <a href="http://trac.parrot.org/parrot/wiki/JITRewrite">JIT info</a></li>
</ul>
</section>
<section>
<h3 id="preprocesor-">4.8 Preprocesor.</h3>
<p>Preprocesor actions is prefix with <code>#</code> and must be at the start of the line.</p>
<section>
<h4 id="-include-uri-">4.8.1 <code>#include</code> <strong>uri</strong></h4>
<p><em>note</em>: <strong>uri</strong> Relative to current file.</p>
<p>Add the file contents into the current position.</p>
<p>This can be used <em>to extend</em> modules, or spread configuration files across your project.</p>
<p>Do not use it to include real code. Use <a href="#modules">modules</a> instead.</p>
</section>
<section>
<h4 id="-replace-regexp-replacement-block-">4.8.2 <code>#replace</code> <strong>regexp</strong> <strong>replacement|block</strong></h4>
<p>Execute given <code>regexp</code> to the file once (just once).</p>
<p>Useful to replace inside strings or literals.</p>
<pre><code>#replace /John/g &quot;Hi \\0&quot;
log &quot;say John&quot;; // stdout: say Hi John

// For multiline you can use block syntax
#replace /John/g {
What are you doing!&quot;;
log &quot;John reply&quot;;
}
</code></pre></section>
<section>
<h4 id="-define-undef-">4.8.3 <code>#define</code> &amp; <code>#undef</code></h4>
<pre><code class="lang-syntax">define-preprocessor
define-object-like
define-function-like

define-object-like
&quot;#define&quot; var-identifier (value|block)

define-function-like
&quot;#define&quot; fn-identifier &quot;(&quot; [&quot;,&quot; *arguments*]? &quot;)&quot; (value|block)

undef-preprocessor
&quot;#undef&quot; var-identifier
</code></pre>
<ul>
<li><p>object-like macro.</p>
<p>Replace variable literals.</p>
</li>
<li><p>function-like macro.</p>
<p>Replace call expressions.
Cannot be undef.</p>
</li>
</ul>
<p>Default compiler definitions.</p>
<p>Any environment variable will be available.</p>
<ul>
<li><p>PLATFORM
linux-32, linux-64, win-32, win-64</p>
</li>
<li><p>DISTRO
debian-X.X.X, ubuntu-X.X.X, centos-X.X.X, win-(xp|7|8)</p>
</li>
<li><p>KERNEL (kernel semver)
X.X.X</p>
</li>
</ul>
</section>
<section>
<h4 id="-ifdef-ifndef-">4.8.4 <code>#ifdef</code> &amp; <code>#ifndef</code></h4>
<p>Check if a idenfifier is defined or not.</p>
<pre><code class="lang-syntax">ifdef-preprocessor
&quot;#ifdef&quot; identifier block-statement &quot;else&quot; ifdef-preprocessor
&quot;#ifndef&quot; identifier block-statement &quot;else&quot; ifdef-preprocessor
</code></pre>
<pre><code class="lang-plee">#ifdef PLATFORM {
  log &quot;out platform is known: &quot;, PLATFORM;
}
</code></pre>
</section>
<section>
<h4 id="-if-">4.8.5 <code>#if</code></h4>
<pre><code class="lang-syntax">if-preprocessor
&quot;#if&quot; assignament-expression block-statement &quot;else&quot; if-preprocessor
</code></pre>
<pre><code class="lang-plee">#if ENV == &quot;dev&quot; {
  #include &quot;dev-config.plee&quot;
} else #if {
  #include &quot;production-config.plee&quot;
}
</code></pre>
</section>
<section>
<h4 id="-error-string">4.8.6 <code>#error</code> string</h4>
<p>Raise a preprocesor error</p>
<pre><code>#if PLATFORM == &quot;mac-32&quot; {
  #error &quot;mac is not supported&quot;
}
</code></pre></section>
<section>
<h4 id="-parser-add-identifier-function-declaration">4.8.7 <code>#parser-add</code> identifier function-declaration</h4>
<p>Inject code directly into the parser.</p>
<p>This require knowledge of the parser itself, use it with caution.</p>
<pre><code>#parser-add read_source_elements function read_if_statement() {
  var ast = ast_new(&quot;xxx&quot;);

  // über mad science!

  return ast_end(ast);
}
</code></pre><p><strong>TODO</strong> when the basic parser is done back here!</p>
</section>
<section>
<h4 id="-meta-text">4.8.8 <code>#meta</code> text</h4>
<p>Set <code>metadata</code> property text in the next AST statement.</p>
<pre><code class="lang-plee">#meta post-process
fn xx {
  return 0;
}
</code></pre>
</section>
<section>
<h3 id="postprocesor-">4.9 Postprocesor.</h3>
<p>Mainly to debug and instrument your code. Allow you to hook AST after being parsed.</p>
<ul>
<li><p><code>#post</code> ast-type block</p>
<pre><code>// log every object before returning
#post &quot;return-statement&quot; {
  var fn = get_nearest_function($0);
  if (fn.return_type == &quot;object&quot;) {
    before($0, &quot;log &quot; + $0.id + &quot;;&quot;);
  }
}
</code></pre></li>
</ul>
<p>Available functions</p>
<ul>
<li>is_defined(object ast, string variable_name)</li>
<li>get_nearest_scope(object ast)</li>
<li>get_nearest_function(object ast)</li>
<li>before(object ast, object insert)</li>
<li>before(object ast, string code)</li>
<li>after(object ast, object insert)</li>
<li>after(object ast, string code)</li>
</ul>
</section>
<section>
<h2 id="entry-point-file-">5 entry-point file.</h2>
<p>In plee there is only one file that can configure your project.
This is the <code>entry-point</code> file.</p>
<p>The <code>entry-point</code> differ from any other file it&#39;s where the program
will start its execution. Like main in c and but more like
node.js or phyton.</p>
<p>From this file you can configure the parser and compiler.
Even if there is no other place to configure that staff you
can always include the contents of a file with <code>#include</code> and split
proyect configuration.</p>
<p>Just now we introduce the preprocessor concept borrowed mostly from c.
Also say that <code>#include</code> read the file a insert its contents,
so only one file will be compiled.</p>
<p>The file is execution goes top to bottom. If you need to create an infinite loop we recommend the <code>loop statement</code>.</p>
<pre><code>var something-happens = false; // &lt;-- shock?!
loop {
  // some nasa science

  if (something-happens) {
    exit 0;
  }
}
</code></pre><p>Did you spot an error?</p>
<p>Are you sure... do not skip the operators, you will understand.</p>
</section>
<section>
<h2 id="operators">6 Operators</h2>
<table>
<thead>
<tr>
<th>Precedence</th>
<th>Operator type</th>
<th>Associativity</th>
<th>Individual operators</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Grouping</td>
<td>n/a</td>
<td>( … )</td>
</tr>
<tr>
<td>1</td>
<td>Member Access</td>
<td>left-to-right</td>
<td><em>lhs</em> <strong>.</strong> <em>rhs</em></td>
</tr>
<tr>
<td>1</td>
<td>Computed Member Access</td>
<td>left-to-right</td>
<td><em>lhs</em> [ … ]</td>
</tr>
<tr>
<td>1</td>
<td>new (with argument list)</td>
<td>n/a</td>
<td>new … ( … )</td>
</tr>
<tr>
<td>2</td>
<td>Function Call</td>
<td>left-to-right</td>
<td><em>lhs</em> (…)</td>
</tr>
<tr>
<td>2</td>
<td>new (without argument list)</td>
<td>right-to-left</td>
<td>new <em>rhs</em></td>
</tr>
<tr>
<td>3</td>
<td>Postfix Increment</td>
<td>n/a</td>
<td><em>lhs</em> ++</td>
</tr>
<tr>
<td>3</td>
<td>Postfix Decrement</td>
<td>n/a</td>
<td><em>lhs</em> --</td>
</tr>
<tr>
<td>4</td>
<td>Logical NOT</td>
<td>right-to-left</td>
<td>! <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Bitwise NOT</td>
<td>right-to-left</td>
<td>~ <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Unary Plus</td>
<td>right-to-left</td>
<td>+ <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Unary Negation</td>
<td>right-to-left</td>
<td>- <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Prefix Increment</td>
<td>right-to-left</td>
<td>++ <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Prefix Decrement</td>
<td>right-to-left</td>
<td>-- <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>typeof</td>
<td>right-to-left</td>
<td>typeof <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>delete</td>
<td>right-to-left</td>
<td>delete <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>resize</td>
<td>right-to-left</td>
<td>resize <em>rhs</em></td>
</tr>
<tr>
<td>4</td>
<td>Exits operator</td>
<td>n/a</td>
<td>! <em>lhs</em>?</td>
</tr>
<tr>
<td>5</td>
<td>Multiplication</td>
<td>left-to-right</td>
<td><em>lhs</em> * <em>rhs</em></td>
</tr>
<tr>
<td>5</td>
<td>Division</td>
<td>left-to-right</td>
<td><em>lhs</em> / <em>rhs</em></td>
</tr>
<tr>
<td>5</td>
<td>Remainder</td>
<td>left-to-right</td>
<td><em>lhs</em> % <em>rhs</em></td>
</tr>
<tr>
<td>6</td>
<td>Addition</td>
<td>left-to-right</td>
<td><em>lhs</em> + <em>rhs</em></td>
</tr>
<tr>
<td>6</td>
<td>Subtraction</td>
<td>left-to-right</td>
<td><em>lhs</em> - <em>rhs</em></td>
</tr>
<tr>
<td>7</td>
<td>Bitwise Left Shift</td>
<td>left-to-right</td>
<td><em>lhs</em> &lt;&lt; <em>rhs</em></td>
</tr>
<tr>
<td>7</td>
<td>Bitwise Right Shift</td>
<td>left-to-right</td>
<td><em>lhs</em> &gt;&gt; <em>rhs</em></td>
</tr>
<tr>
<td>8</td>
<td>Less Than</td>
<td>left-to-right</td>
<td><em>lhs</em> &lt; <em>rhs</em></td>
</tr>
<tr>
<td>8</td>
<td>Less Than Or Equal</td>
<td>left-to-right</td>
<td><em>lhs</em> &lt;= <em>rhs</em></td>
</tr>
<tr>
<td>8</td>
<td>Greater Than</td>
<td>left-to-right</td>
<td><em>lhs</em> &gt; <em>rhs</em></td>
</tr>
<tr>
<td>8</td>
<td>Greater Than Or Equal</td>
<td>left-to-right</td>
<td><em>lhs</em> &gt;= <em>rhs</em></td>
</tr>
<tr>
<td>8</td>
<td>force assignment</td>
<td>left-to-right</td>
<td><em>rhs</em> !</td>
</tr>
<tr>
<td>9</td>
<td>Equality</td>
<td>left-to-right</td>
<td><em>lhs</em> == <em>rhs</em></td>
</tr>
<tr>
<td>9</td>
<td>Inequality</td>
<td>left-to-right</td>
<td><em>lhs</em> != <em>rhs</em></td>
</tr>
<tr>
<td>9</td>
<td>Address Equality</td>
<td>left-to-right</td>
<td><em>lhs</em> $= <em>rhs</em></td>
</tr>
<tr>
<td>10</td>
<td>Bitwise AND</td>
<td>left-to-right</td>
<td><em>lhs</em> &amp; <em>rhs</em></td>
</tr>
<tr>
<td>11</td>
<td>Bitwise XOR</td>
<td>left-to-right</td>
<td><em>lhs</em> ^ <em>rhs</em></td>
</tr>
<tr>
<td>12</td>
<td>Bitwise OR</td>
<td>left-to-right</td>
<td><em>lhs</em> &#124; <em>rhs</em></td>
</tr>
<tr>
<td>13</td>
<td>Logical AND</td>
<td>left-to-right</td>
<td><em>lhs</em> &amp;&amp; <em>rhs</em></td>
</tr>
<tr>
<td>14</td>
<td>Logical OR</td>
<td>left-to-right</td>
<td><em>lhs</em> &#124;&#124; <em>rhs</em></td>
</tr>
<tr>
<td>15</td>
<td>Conditional</td>
<td>right-to-left</td>
<td><em>lhs</em> ? … : <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Safe assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> ?= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> = <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> += <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> -= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> <em>= </em>rhs*</td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> /= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> %= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> &lt;&lt;= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> &gt;&gt;= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> &gt;&gt;&gt;= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> &amp;= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> ^= <em>rhs</em></td>
</tr>
<tr>
<td>16</td>
<td>Assignment</td>
<td>right-to-left</td>
<td><em>lhs</em> &#124;= <em>rhs</em></td>
</tr>
<tr>
<td>17</td>
<td>Spread</td>
<td>n/a</td>
<td>... …</td>
</tr>
<tr>
<td>18</td>
<td>Comma / Sequence</td>
<td>left-to-right</td>
<td><em>lhs</em> , <em>rhs</em></td>
<td></tbody></td>
</tr>
</tbody>
</table>
<!--
| 4 | void | right-to-left | void *rhs* |
| 7 | Bitwise Unsigned Right Shift | left-to-right | *lhs* >>> *rhs* |
| 8 | in | left-to-right | *lhs* in *rhs* |
| 8 | instanceof | left-to-right | *lhs* instanceof *rhs* |
| 9 | Strict Equality | left-to-right | *lhs* === *rhs* |
| 9 | Strict Inequality | left-to-right | *lhs* !== *rhs* |
| 17 | yield | right-to-left | yield *rhs* |
-->
<p>Mathematical operators need to be separated by <code>space</code> for readability
purposes and fully support UTF-8 as identifier.</p>
<pre><code>var x = y + z; // ok
</code></pre><p>See more information about <a href="#var-idenfiers">var-idenfiers</a></p>
<pre><code>var x = y+z; // compilation-error
// undefined variable x+z
</code></pre><section>
<h3 id="variables-types-">6.1 Variables &amp; types.</h3>
<section>
<h4 id="philosophy">6.1.1 Philosophy</h4>
<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Type_introspection">Type introspection</a></p>
</li>
<li><p>Required keyword (var, const, unvar) for readability.</p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Type_inference">Type inference</a></p>
</li>
<li><p>Types lowercased.</p>
</li>
<li><p>Auto scope. Compiler will choose between function or block scope.</p>
</li>
</ul>
</section>
<section>
<h4 id="syntax">6.1.2 Syntax</h4>
<pre><code class="lang-syntax">var-declaration
&#39;export&#39; (&#39;const&#39;|&#39;var&#39;|&#39;unvar&#39;|&#39;static&#39;) (var-declarator)+;

var-declarator
type? var-identifier (&#39;=&#39; (expression|literal))? (&#39;,&#39; var-declarator)*
type var-identifier &#39;(&#39; argument_list &#39;)&#39; (&#39;,&#39; var-declarator)*
</code></pre>
<ul>
<li><code>const</code> for constants</li>
<li><code>var</code> for variables implicit initialized to default values</li>
<li><code>unvar</code> for un-initialized variables</li>
</ul>
<p>examples:</p>
<pre><code class="lang-plee">var a = 0; // i64 (default compiler option)
var b = 0.0; // float (default compiler option)

var d = [1, 2, 3]; // array of i64, size=length=3
var e = a; // same type as a

var ui64 e; // also: i64
log e; // stdout: 0
</code></pre>
</section>
<section>
<h4 id="lazy-initialization-shortcut-">6.1.3 lazy initialization (shortcut)</h4>
<pre><code class="lang-plee">var a = new array(5);
//equivalent to
var array a(5);
</code></pre>
</section>
<section>
<h4 id="type-inference-">6.1.4 Type inference.</h4>
<ul>
<li>Initialization</li>
</ul>
<ul>
<li><p>Initialization without a value</p>
<pre><code>unvar a;
unvar ui64 b;
</code></pre></li>
<li><p>Operators</p>
<p>Resolve the type based on operation over the variable.</p>
<pre><code class="lang-plee">var x = 0, y = 0; //i64
var z = x + y;
</code></pre>
</li>
<li><p>function arguments</p>
<pre><code class="lang-plee">fn sum ui8 x, ui8 y : ui8 {
    return x + y;
}
</code></pre>
</li>
</ul>
</section>
<section>
<h4 id="implicit-type-conversion">6.1.5 implicit type conversion</h4>
<p>A type can only grow in precision.</p>
<pre><code class="lang-plee">var x = 0; // ui64
var y = 0.1; // float
var z = x + y; // float
</code></pre>
</section>
<section>
<h4 id="explicit-type">6.1.6 explicit type</h4>
<pre><code class="lang-plee">var i64 x;
var string str;
</code></pre>
</section>
<section>
<h4 id="explicit-type-conversion">6.1.7 explicit type conversion</h4>
<p><code>to_*</code> functions</p>
<pre><code class="lang-plee">var ui64 x = to_ui64(0.0);
</code></pre>
</section>
<section>
<h4 id="invalid-explicit-conversions">6.1.8 invalid explicit conversions</h4>
<table>
<thead>
<tr>
<th>from</th>
<th>to</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>string</td>
<td>compiler will complain an offer a solution: use join</td>
</tr>
<tr>
<td>function</td>
<td>*</td>
<td>functions cannot be casted</td>
</tr>
<tr>
<td>string</td>
<td>function</td>
<td>compiler will complain an offer a solution: use call operator</td>
</tr>
<tr>
<td>object</td>
<td>array</td>
<td>not allowed <strong>TODO</strong> study</td>
</tr>
<tr>
<td>object</td>
<td>block</td>
<td>compiler will complain an offer a solution: use copy operator</td>
</tr>
<tr>
<td>block</td>
<td>object</td>
<td>compiler will complain an offer a solution: use call operator</td>
</tr>
<tr>
<td>block</td>
<td>*</td>
<td>not allowed</td>
</tr>
<tr>
<td>struct</td>
<td>block</td>
<td>compiler will complain an offer a solution: use copy operator</td>
</tr>
</tbody>
</table>
<p><a name="var-idenfiers"></a></p>
</section>
<section>
<h4 id="variable-identifier-name-rules">6.1.9 Variable identifier/name rules</h4>
<ul>
<li>Cannot start with a number</li>
<li>Cannot contains: <code>$</code>, <code>.</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&quot;</code>, <code>&#39;</code>, <code>@</code></li>
<li>Cannot be a reserved word</li>
<li>Any UTF-8 valid character</li>
</ul>
</section>
<section>
<h4 id="primitives">6.1.10 Primitives</h4>
<ul>
<li><p><strong>bool</strong></p>
<p>There are only two Boolean values, <code>true</code> and <code>false</code>.</p>
<p>But there some aliases:</p>
<ul>
<li><p><code>true</code>: <code>on</code> &amp; <code>yes</code></p>
</li>
<li><p><code>false</code>: <code>of</code> &amp; <code>no</code></p>
</li>
</ul>
<p>Those aliases give more expressiveness to the language.</p>
</li>
<li><p><strong>number</strong></p>
<p>Mutable-multipuporse number. Increase it&#39;s size as needed / overflow happens.</p>
<p>Will be i64 until floating point is needed and change it&#39;s type to f64.</p>
<p>Note: If any calculation produces and error <code>nan</code> (<code>not a number</code>) will be returned.</p>
</li>
<li><p><strong>i8, i16, i32, i64 (int), ui8, ui16, ui32, ui64 (uint)</strong></p>
<p>Integers and unsigned integers of different sizes.</p>
<p>Note: If any calculation produces and error <code>nan</code> (<code>not a number</code>) will be returned.</p>
</li>
<li><p><strong>f32 (float) &amp; f64</strong></p>
<p>Primitive value corresponding to a single/double-precision 32/64-bit binary format IEEE 754 value.</p>
<p>Note: If any calculation produces and error <code>nan</code> (<code>not a number</code>) will be returned.</p>
</li>
<li><p><strong>function</strong></p>
<p>Function as type. Unlike other languages arguments doesn&#39;t matter.</p>
</li>
<li><p><strong>string</strong></p>
<p>Primitive value that is a finite ordered sequence of zero or more 16-bit unsigned integer</p>
<p><em>Properties:</em></p>
<ul>
<li>iterable</li>
<li>shared-ptr</li>
</ul>
</li>
</ul>
</section>
<section>
<h4 id="data-aggregation-complex-types-">6.1.11 Data aggregation, complex types.</h4>
<ul>
<li><p><strong>array</strong></p>
<p>List of things, this is continuous memory and should have a defined type, cannot contains different things (unless pointers are stored).</p>
<p><em>Properties:</em></p>
<ul>
<li>iterable</li>
<li>thread-block</li>
<li>shared-ptr</li>
</ul>
</li>
<li><p><strong>struct</strong></p>
<p>Constant structured data.</p>
<p><em>Properties:</em></p>
<ul>
<li>iterable</li>
<li>thread-block</li>
<li>shared-ptr</li>
</ul>
</li>
<li><p><strong>block</strong></p>
<p>It&#39;s the same as struct but memory continuous.</p>
<p>When you allocate a block you must specify every length in the block.</p>
<p><em>Properties:</em></p>
<ul>
<li>iterable</li>
<li>thread-block</li>
<li>shared-ptr</li>
</ul>
</li>
<li><p><strong>object</strong></p>
<p>Mutable structured data. You could add/remove members.</p>
<p><em>Properties</em></p>
<ul>
<li>iterable</li>
<li>thread-block</li>
<li>shared-ptr</li>
</ul>
</li>
<li><p><strong>p1, p2, p3, p4</strong></p>
<p>Pointer of different sizes (bytes).</p>
<p>There are two types of pointer.</p>
<ul>
<li>Pointer to iterate, those that use memory already allocated.</li>
<li>Pointer to mange memory, those that allocate memory</li>
</ul>
<p><em>Members:</em></p>
<ul>
<li>.start</li>
<li>.end</li>
<li>.length</li>
</ul>
<p><em>Properties:</em></p>
<ul>
<li>alloc / new</li>
<li>dealloc / delete</li>
<li>realloc / resize</li>
<li>copy</li>
</ul>
</li>
</ul>
<!--
* **bin[X]**

  binary data of given number of bytes.

* **stream:type**

  Wrapper for a given subtype that allow processing in chunks.
-->
<ul>
<li><p><strong>null</strong> &amp; <strong>nil</strong></p>
<p><code>null</code> is prefered as <code>nil</code> is introduce it just for laziness.</p>
</li>
</ul>
<!--
* **fnblock**

  Block of code. it could be considered as a function-body.
-->
</section>
<section>
<h4 id="type-properties">6.1.12 Type properties</h4>
<p><strong>iterable</strong></p>
<blockquote>
<p>Has some special methods like: each, filter, reduce...</p>
<p>Can be directly used inside a <code>for-in</code> loop</p>
</blockquote>
<p><strong>thread-block</strong></p>
<blockquote>
<p>A thread can block the usage for the rest of the threads.</p>
<p>When a thread want to use it, first must wait the lock.</p>
</blockquote>
<p><strong>shared-ptr</strong></p>
<blockquote>
<p>Reference-counted shared pointer.</p>
<p>when a variable references counter add 1</p>
<p>when a variable is deleted counter subtract 1</p>
</blockquote>
</section>
<section>
<h4 id="functions-in-modules-">6.1.13 functions in modules.</h4>
<p>Just as a brief introduction, variable in modules has special keyword
to specify their behavior.</p>
<ul>
<li><code>export var</code> allow a variable to be accessed outside the module</li>
<li>There is no way to export a <em>readonly</em> variable.</li>
</ul>
</section>
<section>
<h4 id="special-functions">6.1.14 special functions</h4>
<ul>
<li><p><code>regexp_test</code></p>
<p>Give you support to include your type inside a switch with a regular expression
test.</p>
</li>
<li><p><code>to_string</code></p>
<p>transform your type into an string.</p>
</li>
<li><p><code>to_number</code></p>
<p>Transform your type into a number.</p>
</li>
<li><p><code>to_log</code></p>
<p>Used by log. Native types include the type name before calling <code>to_json</code>.</p>
<p>If the function is not defined, log will use <code>to_string</code> instead.</p>
</li>
<li><p><code>to_json</code></p>
<p>Give you support to enconding: <code>json</code></p>
</li>
<li><p><code>operator</code> &quot;assignament operators&quot;</p>
<p>Allow to use your type on left side of the assignament operators.</p>
<p>All this calls will be inlined if possible.</p>
</li>
</ul>
</section>
<section>
<h3 id="auto-scope">6.2 Auto scope</h3>
<p>Auto scope refers to where your variable is available.</p>
<p>block scope</p>
<pre><code class="lang-plee">{
    var x;
}
// now x is not available.
</code></pre>
<p>function scope</p>
<pre><code class="lang-plee">fn read-file {
  var current_line = 0;
  fn next_line {
    ++current_line; // the compiler see this and use function scope
  }

  while (!eof()) {
    next_line();
  }

  log current_line;
}
</code></pre>
<p>Variable names must be unique at function scope.
So this is not possible.</p>
<pre><code class="lang-plee-err">fn a {
  var i;
  fn b {
    var i;
  }
}
</code></pre>
</section>
<section>
<h2 id="string">7 string</h2>
<p><code>string</code> store UTF-8 characters.</p>
<section>
<h3 id="instance-properties">7.1 instance properties</h3>
<ul>
<li><p><em>ui64</em> size = 0 [readonly]</p>
<p>bytes allocated, remember that UTF-8 is multibyte.</p>
</li>
<li><p><em>ui64</em> used = 0 [readonly]</p>
<p>bytes currently in use.</p>
</li>
<li><p><em>ui64</em> length = 0 [readonly]</p>
<p>Number of characters</p>
</li>
<li><p>string.charsets charset = 0 [readonly]</p>
<p>Number of characters</p>
</li>
</ul>
</section>
<section>
<h3 id="operators">7.2 operators</h3>
<ul>
<li><code>[]</code> access to a single character first byte.</li>
<li><code>+</code> concatenate two strings</li>
<li><code>&gt;</code> &amp; <code>&lt;</code> compare two strings</li>
<li><code>=</code> overwrite lhs and resize if needed</li>
</ul>
</section>
<section>
<h3 id="instance-methods">7.3 instance methods</h3>
<ul>
<li><p><strong>substr</strong> (<em>string</em> str, <em>ui64</em> start != nan, <em>ui64</em> length = infinity != nan)</p>
<p>The substr method takes three arguments, and returns str modified, result of
starting from position start and running for length code units
(or through the end of the string). If start is negative,
it is treated as (str.length + start).</p>
<p>Aliases: <code>slice</code></p>
</li>
<li><p><strong>substring</strong> (<em>string</em> str, <em>ui64</em> start != nan &lt; str.length, <em>ui64</em> end = str.length != nan &lt; str.length)</p>
<p>The substring method takes two arguments, start and end, and returns a substring
of the result of converting this object to a String, starting from character position
start and running to, but not including, character position end of the String
(or through the end of the String is end is undefined). The result is a String value,
not a String object</p>
<p>If start is larger than end, they are swapped.</p>
</li>
<li><p><strong>concat</strong> (<em>string</em> str, <em>string</em> str2)</p>
<p>Return str modified, result of concatenate str and str2.</p>
</li>
<li><p><strong>concat</strong> (clone <em>string</em> str, <em>string</em> str2)</p>
<p>Return a new string, result of concatenate str and str2.</p>
<p>Aliased to <code>operator +</code></p>
</li>
<li><p><strong>resize</strong> (<em>string</em> str, <em>ui64</em> size)</p>
<p>Reallocate memory.</p>
</li>
<li><p><strong>char_at</strong> (<em>string</em> str, <em>ui64</em> pos)</p>
<p>Returns a String containing the character at position pos in the String resulting from
converting this object to a String. If there is no character at that position, the result
is the empty String. The result is a String value, not a String object.</p>
<p>shortcut of: <code>substring(str, pos, pos+1)</code></p>
</li>
<li><p><strong>char_code_at</strong> (<em>string</em> str, <em>ui64</em> pos) : ui64</p>
<p>Returns a Number (a nonnegative integer less than 2<sup>16</sup>) representing the code
unit value of the character at position pos in the String resulting from converting this
object to a String. If there is no character at that position, the result is <code>nan</code>.</p>
</li>
<li><p><strong>code_point_at</strong></p>
</li>
<li><p><strong>index_of</strong>(<em>string</em> haystack, <em>string</em> needle, <em>ui64</em> offset = 0, <em>bool</em> case_insensitive = false) : <em>ui64</em></p>
<p>Find the position of the first occurrence of a substring in a string</p>
</li>
<li><p><strong>contains</strong> (<em>string</em> haystack, <em>string</em> needle, <em>bool</em> case_insensitive = false) : <em>bool</em></p>
<p>Find if <em>needle</em> can be found into <em>haystack</em>.</p>
</li>
<li><p><strong>last_index_of</strong> (<em>string</em> haystack, <em>string</em> needle, <em>ui64</em> offset = 0, <em>bool</em> case_insensitive = false) : <em>bool</em></p>
<p>Find the position of the last occurrence of a substring in a string.</p>
<p><em>offset</em>: If specified, search will start this number of characters counted from the beginning of the string.
If the value is negative, search will instead start from that many characters from the end of the string,
searching backwards.</p>
</li>
<li><p><strong>replace</strong> (<em>string</em> str, <em>string</em> search, <em>string</em> replace, <em>bool</em> case_insensitive = false, <em>ui64</em> count = null)</p>
</li>
<li><strong>replace</strong> (<em>string</em> str, <em>array</em> search, <em>string</em> replace, <em>bool</em> case_insensitive = false, <em>ui64</em> count = null)</li>
<li><p><strong>replace</strong> (<em>string</em> str, <em>array</em> search, <em>array</em> replace, <em>bool</em> case_insensitive = false, <em>ui64</em> count = null)</p>
<p>Replace all occurrences of the search string with the replacement string</p>
<p><em>count</em> If passed, this will be set to the number of replacements performed.</p>
</li>
<li><p><strong>locale_compare</strong></p>
</li>
<li><p><strong>match</strong> (<em>string</em> str, <em>regexp</em> reg_exp, <em>ui64</em> start = 0, <em>ui64</em> end = str.lenght) : <em>bool</em></p>
</li>
<li><p><strong>ocurrences</strong> (<em>string</em> haystack, <em>string</em> needle) : array</p>
<p>Returns a list of indexes with the ocurrences of <em>needle</em> into <em>haystack</em>.</p>
</li>
<li><p><strong>split</strong> (<em>string</em> str, <em>string</em> delimiter, <em>ui64</em> limit = infinity) : <em>array</em></p>
</li>
<li><p><strong>split</strong> (<em>string</em> str, <em>regexp</em> delimiter, <em>ui64</em> limit = infinity) : <em>array</em></p>
<p>Returns an array of strings, each of which is a substring of str formed by splitting
it on boundaries formed by the string delimiter.</p>
<p>If limit is set and positive, the returned array will contain a maximum of limit elements
with the last element containing the rest of string.</p>
<p>If the limit parameter is negative, all components except the last -limit are returned.</p>
<p>alias: <code>explode</code></p>
</li>
<li><p><strong>lowercase</strong>(<em>string</em> str, <em>bool</em> use_locale = true)</p>
<p>Returns string with all alphabetic characters converted to lowercase.</p>
<p>if <em>use_locale</em> is <code>true</code> use current locale options to lowercase. Otherwise locale &quot;C&quot; will be used.</p>
</li>
<li><p><strong>uppercase</strong></p>
<p>Returns string with all alphabetic characters converted to uppercase.</p>
<p>if <em>use_locale</em> is <code>true</code> use current locale options to uppercase. Otherwise locale &quot;C&quot; will be used.</p>
</li>
<li><p><strong>trim</strong> (<em>string</em> str, <em>string</em> character_mask = &quot; \t\n\r\0\x0B&quot;)</p>
<p>Strip whitespace (or given characters) from the beginning and end of a string</p>
</li>
<li><p><strong>ltrim</strong> (<em>string</em> str)</p>
<p>Strip whitespace (or given characters) from the beginning of a string</p>
</li>
<li><p><strong>rtrim</strong> (<em>string</em> str)</p>
<p>Strip whitespace (or given characters) from the beginning and end-</p>
</li>
<li><p><strong>lcfirst</strong> (<em>string</em> str)</p>
<p>Lowercase first leter</p>
</li>
<li><p><strong>ucfirst</strong> (<em>string</em> str)</p>
<p>Uppercase first leter</p>
</li>
<li><p><strong>chunk_split</strong> (<em>string</em> body, <em>ui64</em> chunklen = 64, <em>string</em> end = &quot;\r\n&quot;) : <em>array</em></p>
<p>Split a string into smaller chunks</p>
</li>
<li><p><strong>nl2br</strong> (<em>string</em> string, <em>bool</em> is_xhtml = true): <em>string</em></p>
<p>Returns string with &#39;<br />&#39; (<code>is_xhtml = true</code>) or &#39;<br>&#39; (<code>is_xhtml = false</code>) inserted
before all newlines (<code>\r\n</code>, <code>\n\r</code>, <code>\n</code> and <code>\r</code>).</p>
</li>
<li><p><strong>parse_qs</strong> (<em>string</em> str): <em>array</em></p>
<p>Parses str as if it were the query string passed via a URL.</p>
</li>
<li><p><strong>parse_url</strong>(<em>string</em> str): <em>object</em></p>
<p>This function parses a URL and returns an object containing any of the various
components of the URL that are present.</p>
<p>Returned <em>object</em></p>
<pre><code>{
  &quot;scheme&quot;: string, // http, https, ftp...
  &quot;host&quot;: string, // clean host, no ended with &quot;/&quot;
  &quot;user&quot;: string,
  &quot;pass&quot;: string,
  &quot;path&quot;: string, // starts with &quot;/&quot;
  &quot;query&quot;: string, // querystring
  &quot;fragment&quot;: string,
}
</code></pre><p>Parses str as if it were the query string passed via a URL.</p>
</li>
<li><p><strong>parse_csv</strong> (<em>string</em> input, <em>string</em> delimiter = &quot;,&quot;, <em>string</em> enclosure = &#39;&quot;&#39;, <em>string</em> escape = &quot;\&quot;): <em>array</em></p>
<p>Parses a string input for fields in CSV format and returns an array containing the fields read.</p>
</li>
<li><p><strong>parse_json</strong> (<em>string</em> input): <em>object</em></p>
<p><strong>TODO</strong> study, this return an object ?</p>
</li>
</ul>
<p>One-way string hashing</p>
<ul>
<li><a href="http://php.net/manual/en/function.ord.php">ord</a></li>
<li>parse_http_get</li>
</ul>
<section>
<h4 id="crypto-related">7.3.1 crypto related</h4>
<ul>
<li><a href="http://php.net/manual/en/function.crypt.php">crypt</a></li>
<li><a href="http://php.net/manual/en/function.sha1.php">sha1</a></li>
<li><a href="http://php.net/manual/en/function.md5.php">md5</a></li>
<li><a href="http://php.net/manual/en/function.crc32.php">crc32</a></li>
</ul>
</section>
<section>
<h3 id="string-properties-under-study-">7.4 string properties (under study)</h3>
<ul>
<li><p><em>ui64</em> pool_size = 1m [mutable]</p>
<p>Determine the minimum memory reserved anytime for string operations.</p>
</li>
<li><p><em>ui64</em> max_size = 2m [mutable]</p>
<p>From this point memory will be released if destruction happens, and meet certain criteria.</p>
</li>
<li><p><em>ui32</em> deallocations [readonly]</p>
<p>Counter</p>
</li>
<li><p><em>ui32</em> .allocations [readonly]</p>
<p>Counter</p>
</li>
<li><p><em>f32</em> .fragmentation [readonly]</p>
<p>Fragmentation factor.</p>
</li>
</ul>
</section>
<section>
<h3 id="string-allocation-function-under-study-">7.5 string allocation function (under study)</h3>
<ul>
<li><p>.defrag <strong>TODO</strong> study more</p>
<p>Sort all memory strings in a new place.</p>
</li>
</ul>
<p><strong>TODO</strong> Study more.</p>
<p>support memory management profiles/allocators?</p>
<ul>
<li>continuous pool</li>
<li><p>on demand</p>
</li>
<li><p>ord, make sense ? will be utf-16</p>
</li>
<li>base64 where?</li>
<li>number_format where?</li>
<li>currency_format where?</li>
</ul>
</section>
<section>
<h2 id="number-types">8 Number types</h2>
<p>Any number type has the following properties.</p>
<ul>
<li><p>.infinity</p>
</li>
<li><p>.minfinity</p>
</li>
<li><p>.max</p>
<p>Maximum number represented</p>
</li>
<li><p>.min</p>
<p>Minimum number represented</p>
</li>
<li><p>.min_resolution</p>
<p>Minimum resolution.</p>
<p>1 for integers</p>
<p>[STUDY] f32 &amp; f64</p>
</li>
<li><p>.round</p>
<p>round function behavior.</p>
<p>0 toward zero
1 to nearest
2 toward positive infinity
3 toward negative infinity</p>
</li>
<li><p>.null</p>
<p>Default value for a not initialized number.</p>
</li>
</ul>
<p>Number with decimals has special properties</p>
<ul>
<li><p><em>epsilon</em> = 0</p>
<p>epsilon can be modified at compile time.</p>
<p>If you set epsilon many times in your program, the last one prevail. So it&#39;s recommended to do it in the configuration file.</p>
<p>When set, modify <code>a == b</code> to <code>-epsilon &lt; (a - b) &lt; epsilon</code>, So there is a performance hit, but avoid floating points errors.</p>
</li>
</ul>
<p>Number representations</p>
<ul>
<li><p>binary</p>
<p>0b[0-1]</p>
<p>number will be truncated to nearest 8 byte possible. 0b0101 (is in fact 0b00000101)</p>
</li>
<li><p>hecadecimal</p>
<ul>
<li>0x(abcdef0123456789)</li>
<li>0#(abcdef0123456789)</li>
</ul>
</li>
<li><p>octal</p>
<p>0o(01234567)</p>
</li>
</ul>
<p>bitmask dir {
  north, // =1,
  east,  // = 2,
  south, // = 4,
  west   // = 8
}</p>
<p>var dir diagonal = dir.north | dir.east;</p>
</section>
<section>
<h2 id="enum">9 enum</h2>
<pre><code class="lang-syntax">enum-declaration
&#39;export&#39;? &#39;expand&#39;? &quot;enum&quot; var-identifier &quot;{&quot; [&quot;,&quot; var-identifier (&quot;:&quot; integer)? ]+ &quot;}&quot;  &quot;;&quot;
</code></pre>
<p>expand leaks enum identifier to current scope, and if it&#39;s exported to the module interface.</p>
<pre><code class="lang-plee">
enum dirs {north, west, south, east};

int i = dirs.north;

expand enum DIRS {NORTH, WEST, SOUTH, EAST};

int j = NORTH;
</code></pre>
</section>
<section>
<h2 id="pointers">10 Pointers</h2>
<p><strong>TODO</strong> this need review and a real comparison with c-pointers.</p>
<p>There many types of pointers.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>target</th>
<th>can move?</th>
<th>own memory</th>
<th>dereferenced</th>
<th>safe</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ref</code></td>
<td>single</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td><code>itr</code></td>
<td>range</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td><code>ptr</code></td>
<td>multiple</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<section>
<h3 id="-ref-">10.1 <code>ref</code></h3>
<p>Points to a single memory address, is dereferenced because there
is no operation that can be perform on the pointer apart from assign to other memory address.</p>
<pre><code class="lang-plee">var ui8 a = 1;
var ui8 b = 2;

// @ means address
var ref pa = @a; // reference to a
var ref pb = @b; // reference to b


// ref is always dereferenced for easy to use.
a = a + pb;
log a; // stdout: 3

pa = pb; // remember dereferenced so assign value
log a; // stdout: 2

pa = @pb; // now pa and pb point to b

// has the same value?
log (pa == pb); // stdout: true

// now something tricky.
// @pa points to a address or pa addres
log (@pa == @pb); // stdout: true
// points to a addres.
// you can&#39;t have a ref to a ref for security
</code></pre>
<p>For safety reasons you can&#39;t access the <code>ref</code> address.</p>
<p><strong>STUDY</strong> use &#39;===&#39; to compare <code>ref</code> addresses.</p>
<p>References do not own memory, but some structures like
array will transfer memory ownage to <code>ref</code>. let&#39;s see an example.</p>
<pre><code class="lang-plee">var arr = [1,2,3];
var ref c = @arr; // reference arr

delete arr;

log c[0]; // 1

log arr[0]?; // null
</code></pre>
<p><strong>compiler notes</strong></p>
<ul>
<li><p>ref dont have pointer arithmetic</p>
</li>
<li><p>ref must have a pointer to the memory owner it pointing to.</p>
<pre><code class="lang-plee">var x = ui8[10];
var ref xptr = x[5];
delete x;
</code></pre>
<p>xptr must have a pointer to x. If x is deleted like in the example.
x memory must not be freed until xptr is deleted.</p>
</li>
<li><p>ref is always dereferenced except on left side equal and
address on right side.</p>
</li>
</ul>
</section>
<section>
<h3 id="-pitr-">10.2 <code>pitr</code></h3>
<p>Pointer iterator.</p>
<p>Properties</p>
<ul>
<li><p><strong>ui64</strong> <code>length</code></p>
<p>readonly.</p>
</li>
<li><p><strong>rawp</strong> <code>start</code></p>
<p>readonly.</p>
</li>
<li><p><strong>rawp</strong> <code>end</code></p>
<p>readonly.</p>
</li>
<li><p><strong>rawp</strong> <code>current</code></p>
</li>
<li><p><strong>ref</strong> <code>value</code></p>
<p>fake property that dereference current.</p>
<p>current is dereferenced by the compiler.</p>
</li>
</ul>
<p>Operator</p>
<ul>
<li><p>operator++</p>
<p>alias of next(1);</p>
</li>
<li><p>operator--</p>
<p>alias of prev(1);</p>
</li>
<li><p>operator+ amount:ui64</p>
<p>alias of (clone pitr).next(amount)</p>
</li>
<li><p>operator+= amount:ui64</p>
<p>alias of pitr.next(amount)</p>
</li>
<li><p>operator- amount:ui64</p>
<p>alias of pitr.next(amount)</p>
</li>
<li><p>operator-= amount:ui64</p>
<p>alias of (clone pitr).prev(amount)</p>
</li>
</ul>
<p>Members</p>
<ul>
<li><p><code>reset</code>()</p>
<p>back to start</p>
</li>
<li><p><code>next</code>(ui64 <strong>amount</strong> = 1)</p>
<p>go to next and return false if the end reached or no action is performed.</p>
</li>
<li><p><code>prev</code>(ui64 <strong>amount</strong> = 1)</p>
<p>go to previous and return false if the beginning reached or no action is performed.</p>
</li>
</ul>
<pre><code class="lang-plee">var l = new array[10];
l.fill(10);

var itr = l.iterator();

while (itr.next()) {
    log itr.current; // stdout (10 times): 10
}

assert @itr.current == @itr.last &quot;end reached&quot;;

delete itr; // do not delete l memory
</code></pre>
<p><strong>compiler-notes</strong></p>
<ul>
<li><p>as ref, must save a pointer to the memory owner to avoid free
memory.</p>
</li>
<li><p>once a pitr is assigned to an array, the array will be static.</p>
</li>
</ul>
</section>
<section>
<h3 id="-rawp-">10.3 <code>rawp</code></h3>
<p>Raw C-like pointer, for maximum performance.
It&#39;s not safe to use because has no bounds check, do not have a pointer
to memory owner to avoid free-ing.</p>
<p>Use it with caution.</p>
<p>Compiler notes:</p>
<ul>
<li><p><code>var rawp x = new ui8[1];</code></p>
<p>should raise a compilation error. Even if possible, there is no
variable that own the memory, a rawp canot be deleted</p>
</li>
</ul>
</section>
<section>
<h2 id="array">11 array</h2>
<ul>
<li><p>Arrays are always dense.</p>
</li>
<li><p>Arrays always contains a common type</p>
</li>
<li><p>Assign a pointer to something in the array it&#39;s only possible
if fixed size.</p>
</li>
</ul>
<pre><code class="lang-syntax">array-literal
&quot;[&quot; array-item-list &quot;]&quot;

array-item-list
assignament-expression (&quot;,&quot; assignament-expression)
</code></pre>
<section>
<h3 id="declaration-initialization">11.1 Declaration &amp; Initialization</h3>
<ul>
<li>dynamic arrays use &#39;var&#39; declaration.</li>
<li>static arrays use &#39;static&#39; declaration.</li>
</ul>
<p>dynamic stack array</p>
<blockquote>
<p>var <em>type</em>[<em>size</em>] var-identifier = [<em>values</em>]</p>
</blockquote>
<p>static stack array</p>
<blockquote>
<p>static <em>type</em>[<em>size</em>] var-identifier = [<em>values</em>]</p>
</blockquote>
<p>dynamic heap array</p>
<blockquote>
<p>var var-identifier = <em>new</em> <em>type</em>[<em>size</em>]</p>
<p>var <em>type</em>[<em>size</em>] var-identifier = <em>new</em> [<em>values</em>]</p>
</blockquote>
<p>static heap array</p>
<blockquote>
<p>static var-identifier = <em>new</em> <em>type</em>[<em>size</em>]</p>
<p>static <em>type</em>[<em>size</em>] var-identifier = <em>new</em> [<em>values</em>]</p>
</blockquote>
<p>Some examples will give you some insights.</p>
<pre><code class="lang-plee">// array initializations examples

// dynamic arrays
var stack_dynamic = []; // empty size=0
var stack_dynamic2 = [1, 2]; // array size=2 type is number[]
var ui8[15] stack_dynamic3 = [1, 2]; // length=2, size=15

var heap_static = new ui8[10]; // array size=10
defer delete heap_dynamic; // defer delete so we don&#39;t forget

// static arrays
static ui8[10] stack_static; // size=10
static heap_static = new ui8[10]; // 10 numbers
defer delete heap_static; // defer delete so we don&#39;t forget

// multi-dimensional arrays
var mul_dyn_ar = [[1], [1]];
// **STUDY** this is ugly
var mul_st_ar = ui8[2][2]; // 2x2


// clone an array
var dyn_ar = clone dyn_ar2;

// index access
log dyn_ar[0]; // stdout 1

var dyn_ar_sl = [1, 2, 3];
// static slice, reference same memory
var st_slice = dyn_ar_sl[0:2];
// dynamic slice, clone the memory
var dyn_slice = dyn_ar_sl.slice(0, 2);

assert (st_slice.length != dyn_ar_sl.length) || (dyn_slice.length != dyn_ar_sl.length);

st_slice[0] = 1;
dyn_slice[0] = 2;

assert st_slice[0] == dyn_slice[0];
</code></pre>
</section>
<section>
<h3 id="multi-dimensional-implementation-compiler-notes-">11.2 multi-dimensional implementation (compiler-notes)</h3>
<p><code>multi-dimensional</code> arrays are a different type, that is not directly
exposed to user.</p>
<p>To be performance, must be memory continous, parser cannot solve this problem if the array is not fixed-size, so need to be solved as compile-runtime.</p>
<p><strong>Study</strong> this lead to some problems.
All array functions must has an offset/length, to work on continuous memory. for example:</p>
<pre><code class="lang-plee">var ar = ui8[5][6];
ar[1].indexOf(0);

// will be compiled to
ar.indexOf(0, 6, 12);
</code></pre>
</section>
<section>
<h3 id="array-instance-properties">11.3 Array instance properties</h3>
<ul>
<li><p><code>length</code></p>
<p>readonly. Number of elements.</p>
</li>
<li><p><code>size</code></p>
<p>readonly. Reserved memory (bytes)</p>
</li>
<li><p><code>last</code> (shortcut)</p>
<p>Last element in the array, no more array[array.length -1]</p>
</li>
<li><p>[<strong>index</strong>:<strong>ui64</strong>] (shortcut)</p>
<p>Access to given index</p>
</li>
<li><p><code>index</code> (ui64 pos, ...)</p>
<p>Get the value in the given pos.
If the array is multi-dimensional</p>
</li>
</ul>
</section>
<section>
<h3 id="transformations-transcoding">11.4 transformations/transcoding</h3>
<ul>
<li><p><code>to_string</code></p>
<p>Return the JSON representation.</p>
</li>
<li><p><code>to_number</code></p>
<p>Return the length.</p>
<p><strong>STUDY</strong> This could lead to problems but could avoid check against <code>array.length</code> for lazy people...</p>
</li>
<li><p><code>to_object</code></p>
<p>Return a new <code>object</code> with indexes as keys (casted to string),
values as values.</p>
</li>
</ul>
<!--
 // change id-property and returned as Object

.for: -> raise runtime error
.switch: -> raise runtime error
.is: // memory position check -> check length. if the same, loop every item and do `this[i] is that[i]`
-->
</section>
<section>
<h3 id="array-functions">11.5 array functions</h3>
<p><strong>STUDY</strong> i have to add <em>any</em> as type, because <code>index_of</code> neede it.
But is this possible in our type-system?
Also sort... could lead to some problems...
Even with type inference, some types could need something special...</p>
<ul>
<li><p><code>concat</code> (<em>array</em> ar, ...)</p>
<p>Returns a new array comprised of the array on which it is called joined with the array(s) and/or value(s) provided as arguments.</p>
<p>Must have at least one argument, use <code>clone</code> instead.</p>
</li>
<li><p><code>append</code></p>
<p>Returns current array joined with the array(s) and/or value(s) provided as arguments.</p>
</li>
<li><p><code>join</code> (<em>string</em> separator)</p>
<p>Return a string resulting of join all elements with given separator.</p>
</li>
<li><p><code>last_index_of</code>(<em>any</em> search_element, <em>ui64</em> from_index = length)</p>
<p>Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex (length by default)</p>
</li>
<li><p><code>index_of</code>(<em>any</em> search_element, <em>ui64</em> from_index = 0)</p>
<p>Returns the first index at which a given element can be found in the array, or -1 if it is not present.</p>
</li>
<li><p><code>has_any</code>(<em>array</em> search_array)</p>
<p>Returns if any of the values in searchArray is contained in the array.</p>
<p>alias: <code>contains</code></p>
</li>
<li><p><code>reverse</code> ()</p>
<p>Reverse array.</p>
</li>
<li><p><code>sort</code> (<em>fn</em> func)</p>
<p>sort your array.</p>
<p>func must return a ui64.</p>
<ul>
<li>negative means lesser</li>
<li>0 equal</li>
<li>position means greater</li>
</ul>
</li>
<li><p><code>splice</code> (<strong>ui64</strong> index, <strong>ui64</strong> how_many, <strong>array</strong> elements, ...)</p>
<p>Changes the content of an array, adding new elements while removing old elements</p>
</li>
<li><p><code>remove</code> (<strong>any</strong> element, <strong>ui64</strong> how_many, <strong>array</strong> elements ...)</p>
<p>Changes the content of an array, adding new elements while removing old elements</p>
</li>
<li><p><code>shift</code> ()</p>
<p>Removes the first element from an array and returns that element. This method changes the length of the array</p>
</li>
<li><p><code>slice</code> (<strong>ui64</strong> begin, <strong>ui64</strong> end = length)
Returns a shallow copy of a portion of an array into a new array object</p>
</li>
<li><p><code>pop</code> ()</p>
<p>Removes the last element from an array and returns that element</p>
</li>
<li><p><code>push</code> (<strong>any</strong> element, ...)</p>
<p>Adds one or more elements to the end of an array and returns the new length of the array</p>
</li>
<li><p><code>insert</code> (<strong>any</strong> element, <strong>ui64</strong> index)</p>
<p>Insert an element into the given position.</p>
</li>
<li><p><code>unshift</code> (<strong>any</strong> element, ...)</p>
<p>Adds one or more elements to the beginning of an array and returns the new length of the array.</p>
</li>
<li><p><code>fill</code> (<strong>any</strong> value)</p>
<p>Fill the array (all size reserved) with the given value.</p>
</li>
</ul>
</section>
<section>
<h3 id="looping">11.6 looping</h3>
<p>For evey function listed here if the function is anonymously declared, the compiler will transform them into a blocks for performance.</p>
<ul>
<li><p><code>every</code> <strong>array</strong> arr, <strong>fn</strong> callback(<strong>any</strong> element,
<strong>ui64</strong> index, <strong>array</strong> arr) : boolean</p>
<p>Tests whether all elements in the array pass the test implemented by the provided function.</p>
</li>
</ul>
<ul>
<li><p><code>filter</code> <strong>array</strong> arr, <strong>fn</strong> test(<strong>any</strong> element,
<strong>ui64</strong> index, <strong>array</strong> arr)) : array</p>
<p>Modify <em>arr</em> removing all elements don&#39;t pass the test
implemented by the provided <em>test</em> function.</p>
</li>
<li><p><code>for_each</code> <strong>array</strong> arr, <strong>fn</strong> callback(<strong>any</strong> element,
<strong>ui64</strong> index, <strong>array</strong> arr)</p>
<p>Executes a provided function once per array element</p>
<p>alias: <strong>each</strong></p>
</li>
<li><p><code>map</code> <strong>array</strong> arr, <strong>fn</strong> callback(<strong>any</strong> element,
<strong>ui64</strong> index, <strong>array</strong> arr)</p>
<p>Modify <em>arr</em> with the results of calling a provided function
on every element in this array.</p>
<p>The callback must return the same value that the array contains.</p>
</li>
<li><p><code>reduce</code> <strong>array</strong> arr, <strong>fn</strong> accumulator(<strong>any</strong> previous_el,
<strong>any</strong> current_el, <strong>ui64</strong> index, <strong>array</strong> arr) : <strong>any</strong></p>
<p>Applies a function against an <em>accumulator</em> and each value of
the array (from left-to-right) has to reduce it to a single value.</p>
<p>Returned value is defined by the callback itself.</p>
</li>
<li><p><code>reduce_right</code> <strong>array</strong> arr, <strong>fn</strong> accumulator(
<strong>any</strong> previous_el, <strong>any</strong> current_el, <strong>ui64</strong> index,
<strong>array</strong> arr) : <strong>any</strong></p>
<p>Applies a function against an <em>accumulator</em> and each value of
the array (from right-to-left) has to reduce it to a single value.</p>
<p>Returned value is defined by the callback itself.</p>
</li>
<li><p><code>some</code>  <strong>array</strong> arr, <strong>fn</strong> callback(<strong>any</strong> element,
<strong>ui64</strong> index, <strong>array</strong> arr)</p>
<p>Tests whether some element in the array passes the test implemented by the provided function</p>
</li>
</ul>
<p><a name="array-iterators"></a></p>
</section>
<section>
<h3 id="iterators">11.7 iterators</h3>
<p><code>for-itr</code> need an iterator that behave. These are their rules:</p>
<ul>
<li>When remove an object, all iterators need to be notified.
And if the element is the current element of someone, the next will have the same ID (do not increment)</li>
</ul>
<pre><code>var a = [1, 2, 3];
var itr1 = a.iterator();
var itr2 = a.iterator();
itr1.next();
itr2.next();

// remove current object
itr2.remove();

// this is not an alias of
// a.splice, has the extra logic to keep iterator sane
// splice NOT!

log itr1; // stdout: 2
log itr2; // stdout: 2

itr1.next();
itr2.next();

log itr1; // stdout: 3
log itr2; // stdout: 3
</code></pre><ul>
<li>splice/push</li>
</ul>
</section>
<section>
<h3 id="notes">11.8 Notes</h3>
<ul>
<li>if type is defined, when enter a switch gives a compile error.</li>
</ul>
</section>
<section>
<h2 id="struct-union">12 struct &amp; union</h2>
<p>Structs are complex data type declaration
that defines a physically grouped list of variables and
functions to be placed under one name in a block of memory.</p>
<p>Unions are different layouts of the same block of memory. Only one
should be used at a given time. The size will be the minimum required
to store any layout (so the biggest of all).</p>
<p>Functions have direct access to those variables in the group by their name if no collision occur, and using <code>struct_name.property</code> otherwise</p>
<p>Pointer variables can be reserved, resized but not deleted.
Their memory is owned by the struct, and memory will be
freed when the struct is deleted.
If you need to free a pointer memory inside a struct,
use <code>resize xx.xx[0]</code>.</p>
<section>
<h3 id="syntax">12.1 Syntax</h3>
<pre><code class="lang-syntax">struct-declaration
(&#39;compact&#39;)? &#39;struct&#39; var-identifier (&#39;extends&#39; var-identifier)? block-body

union-declaration
&#39;union&#39; var-identifier block-body

block-body
&#39;{&#39; (&#39;merge&#39;? var-declaration &#39;;&#39;|fn-declaration)+ &#39;}&#39;
</code></pre>
<p><a name="struct-example"></a></p>
<pre><code class="lang-plee">struct v2 {
  var number x = 0;
  var number y = 0;

  fn add _x, _y {
    // notice that v2.x point to x member and not the global variable.
    v2.x += _x;
    // but v2 can be avoided if no name collision
    y += _y;

    return v2;
  }
};

fn add v2 v, _x, _y: v2 {
    v.x -= _x;
    v.y -= _y;

    return v;
}

var v2 instance;
instance.add(5, 6);
log instance.x; // stdout: 5
log instance.y; // stdout: 6

instance.subtract(5, 6);
log instance.x; // stdout: 0
log instance.y; // stdout: 0
</code></pre>
<p>see <a href="#with">with</a> statement for access shortcuts.</p>
</section>
<section>
<h3 id="index-property-access">12.2 index/property access</h3>
<p>A struct can be access by index (like arrays) or named properties.</p>
<pre><code class="lang-plee">assert v2[0] == v2.x;
assert v2[1] == v2.y;
</code></pre>
<p>The struct itself have some extra properties</p>
<pre><code class="lang-plee">assert v2.length == 2;
assert v2.properties == [&quot;x&quot;, &quot;y&quot;];
assert v2.types == [&quot;number&quot;, &quot;number&quot;];
assert v2.size == 8; // bytes
</code></pre>
</section>
<section>
<h3 id="extends">12.3 extends</h3>
<p>Simple struct inheritance.
Notice: A struct can be downcasted if nobody in the inheritance chain is <code>compact</code>.</p>
</section>
<section>
<h3 id="compact">12.4 compact</h3>
<p>Compact will shrink the memory footprint of the struct to the
minimum.</p>
<ul>
<li>Sorting properties (reducing paddings)</li>
<li>merging bools into bitmask.</li>
</ul>
<p>Why <code>compact</code> is not by default? It increase performance...</p>
<p>Because break save/load binary data compatibility, adding a new property at the end could break your code.</p>
<p><code>compact</code> is just to show you how to re-arrange your struct. use
<code>log</code> how your struct is in memory.</p>
<p>In contrast it&#39;s useful with <code>extends</code>, because it will rearrange all
properties, but, remember that then cannot be downcasted.</p>
<pre><code class="lang-plee">struct v2 { var ui8 x; var ui8 y; };
compact struct v3c extends { var ui8 z; };
struct v3 extends { var ui8 z; };

// init ordered
v3c vecc3(1,2, 3);

// init by name
v3 vec3(x: 1, y: 2, z: 3);

v2 vec2 = (vec2) v3; // this is valid
</code></pre>
<pre><code class="lang-plee-err">// v3c cannot be downcasted, because is compact
v2 vec2_err = (vec2) v3c;
</code></pre>
</section>
<section>
<h3 id="parser">12.5 parser</h3>
<ul>
<li><p><code>#set lazy_struct_var 1</code></p>
<p>optional <code>var</code> inside struct, more like c</p>
</li>
</ul>
</section>
<section>
<h3 id="implementation-notes">12.6 implementation notes</h3>
<p>Functions inside the struct must be hoisted outside the struct and
prepend a new argument of the struct type with the struct name.
Because functions can be called as classy and functional
this remove complexity to the compiler once more and move
it to parser.</p>
</section>
<section>
<h2 id="block">13 block</h2>
<p>It&#39;s the same as struct but memory continuous.</p>
<p>To be memory continuous, sizes of all arrays must
be defined at once, and can obly be allocated in the heap.</p>
<p>Syntax</p>
<pre><code class="lang-syntax">block-declaration
&#39;block&#39; var-identifier [&quot;,&quot; var-identifier]+ block-body;

block-body
&#39;{&#39; (var-declaration|fn-declaration)+ &#39;}&#39;
</code></pre>
<pre><code class="lang-plee">
// declaration
block blk a, b {
  var ui8[a] a_list;
  var ui8[b] b_list;
};

// initialization
var x = new blk(10, 10);

// can be resized
resize x(15, 10); // note: this will allocate, copy and free the old memory.
</code></pre>
<pre><code class="lang-plee-err">resize x.ptr_a[0]; // compilation error
delete x.ptr_a[15]; // compilation error
// block property cannot freed, you must free the entire block
</code></pre>
<p>note: do not need to store the size/length in the array.
both a_list and b_list will be arrays and will have
<code>.length</code> and <code>.size</code>.</p>
<section>
<h3 id="implementation">13.1 Implementation</h3>
<p>example:</p>
<pre><code class="lang-plee">// declaration
block ab_blk a, b {
  var ui8[a] a_list;
  var ui8[b] b_list;
};
</code></pre>
<ul>
<li>a_list will be a raw pointer to a-array</li>
<li>b_list will be a raw pointer to b-array</li>
</ul>
<p>both arrays will be at the end of the structure.</p>
<p>Memory map:</p>
<table>
<thead>
<tr>
<th style="text-align:center">a*</th>
<th style="text-align:center">b*</th>
<th style="text-align:center">a-array</th>
<th style="text-align:center">b-array</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a-array</td>
<td style="text-align:center">b-array</td>
<td style="text-align:center">contents</td>
<td style="text-align:center">contents</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/llafuente/language/blob/master/playground/contiguos-memeory.c">POC</a></p>
</section>
<section>
<h3 id="interlace-proposal-">13.2 interlace (proposal)</h3>
<p>Because the implementation is so difficult i just leave the note.</p>
<p>Interlaced array memory.</p>
<p>Example (plee/c-ish)</p>
<pre><code>// declaration
block ab_blk a, b {
  var ui8[a] a_list;
  var ui8[b] b_list;
};

var ab_blk = new ab_blk(2, 2);
ab_blk.a_list[0] = 1;
ab_blk.a_list[1] = 2;
ab_blk.b_list[0] = 3;
ab_blk.b_list[1] = 4;
var ptr p = @ab_blk.a_list;
for i8 i = 0 .. 4 {
    log *p; //c-ish
    ++p;
}
</code></pre><p>this will log:</p>
<ul>
<li>1 (ab_blk.a_list[0])</li>
<li>3 (ab_blk.b_list[0])</li>
<li>2 (ab_blk.a_list[1])</li>
<li>4 (ab_blk.b_list[1])</li>
</ul>
</section>
<section>
<h2 id="objects">14 Objects</h2>
<p>Abstract data type composed of a collection of (key, value) pairs.</p>
<p>Keys are always a unique string.
Numbers cannot be assigned without casting. Because <code>!</code> operator need to be sure of what type are involved (<a href="#!operator">see below</a>).</p>
<p>Values are pointers and can be repeated.</p>
<p>Objects are declared using JSON-like format.
Last comma is required (atm) for version control system cleaning.</p>
<pre><code class="lang-syntax">object-declaration
&#39;{&#39; (object-property-declaration)* &#39;}&#39;

object-property-declaration
string-literal &#39;:&#39; (literal|expression) &#39;,&#39;
var_identifier &#39;:&#39; (literal|expression) &#39;,&#39;
</code></pre>
<pre><code>var d;
var xxx = {
  &quot;a&quot;: &quot;world&quot;,
  &quot;b&quot;: hello(), // function
  &quot;c&quot;: variable, // variable, dont forget the last comma!
  d: hello(), // variable as key :)
};
</code></pre><section>
<h3 id="methods">14.1 methods</h3>
<ul>
<li><p><code>$has</code> <strong>object</strong> obj, <strong>string</strong> key : <strong>bool</strong></p>
<p>Return if given key is defined.</p>
</li>
<li><p><code>$keys</code> <strong>object</strong> obj : <strong>array</strong></p>
<p>Returned keys are always sorted.</p>
</li>
<li><p><code>$get</code> <strong>object</strong> obj, <strong>string</strong> key, <strong>bool</strong> safe = false) : <strong>any</strong></p>
<p>Get value, if <code>safe=false</code> will raise a run-time-error</p>
</li>
<li><p><code>$set</code> <strong>object</strong> obj, <strong>string</strong> key, <strong>ptr</strong> value) : <strong>bool</strong></p>
<p>Set/overwrite given key with given value.</p>
<p>if the key stats with <code>$</code> a runtime error is raised.</p>
</li>
<li><p><code>$delete</code> <strong>object</strong> obj, <strong>string</strong> key : <strong>any</strong></p>
<p>Remove given key and return pointer or null.</p>
</li>
<li><p><code>$setter</code> <strong>object</strong> obj, <em>fn</em> <strong>sttr</strong> = null : <strong>function</strong></p>
<p>Set a setter function that will be called before each set.</p>
<p>if null is provided will remove the previous setter.</p>
</li>
<li><p><code>$getter</code> <strong>object</strong> obj, <em>fn</em> <strong>gttr</strong> = null : <strong>function</strong></p>
<p>Set a getter function that will be called before each get.</p>
<p>if null is provided will remove the previous getter.</p>
</li>
</ul>
</section>
<section>
<h2 id="-exits-operator-nested-has-shortcut-">15 <code>?</code> exits operator (nested <code>$has</code> shortcut)</h2>
<p>Object has a special method <code>$has</code> but it recommended to use the <code>?</code> operator for readability purposes.</p>
<pre><code>if xxx.say.hello? {
  // do something
}

if xxx.hello? == 10 { // expanded to xxx.$has(&quot;hello&quot;) &amp;&amp; xxx.hello == 10
  // do something
}
</code></pre><p>Compiler will expand this operator using $has</p>
<blockquote>
<p>xxx.say.hello?</p>
</blockquote>
<pre><code>xxx.$has(&quot;say&quot;) ? (xxx.say.$has(&quot;hello&quot;) ? xxx.say.hello : null)  : null
</code></pre><p><strong>TODO</strong> review, this operator is maybe safe at the begining.</p>
</section>
<section>
<h2 id="-safe-asignament">16 <code>?</code> safe asignament</h2>
<p><code>?</code> operator can be used in assignment expressions.
Compiler will expand your code and give you a reasonable collection of runtime-errors.</p>
<blockquote>
<p>xxx.first.second.third? = &quot;just a string&quot;;</p>
</blockquote>
<pre><code>if (!xxx.$has(&quot;first&quot;)) error &quot;xxx has no index &#39;first&#39;&quot;;
if (&quot;object&quot; === typeof xxx.$get(&quot;first&quot;)) error &quot;invalid type of xxx.first&quot;;

if (!xxx.$get(&quot;first&quot;).$has(&quot;second&quot;)) error &quot;undefined xxx.first&quot;;
if (&quot;object&quot; === typeof xxx.$get(&quot;first&quot;).$get(&quot;second&quot;)) error &quot;invalid type of xxx.first.second&quot;;

//...
xxx.$get(&quot;first&quot;).$get(&quot;second&quot;).$get(&quot;third&quot;)[0] = &quot;just a string&quot;;
</code></pre><p>Because key in objects are always string, safe assignaments will initialize arrays if a number is found.</p>
<pre><code>? xxx.first.second.third[0] = &quot;just a string&quot;;

// expanded...
if (!xxx.$has(&quot;first&quot;)) error &quot;undefined xxx.first&quot;;
if (&quot;object&quot; === typeof xxx.$get(&quot;first&quot;)) error &quot;invalid type of xxx.first&quot;;

if (!xxx.$get(&quot;first&quot;).$has(&quot;second&quot;)) error &quot;undefined xxx.first&quot;;
if (&quot;object&quot; === typeof xxx.$get(&quot;first&quot;).$get(&quot;second&quot;)) error &quot;invalid type of xxx.first.second&quot;;

//...
xxx.$get(&quot;first&quot;).$get(&quot;second&quot;).$get(&quot;third&quot;)[0] = &quot;just a string&quot;;
</code></pre><p><a name="!operator"></a></p>
</section>
<section>
<h2 id="-force-asignament">17 <code>!</code> force asignament</h2>
<p>A more inteligent compiler should now how to assign complex things based just on knowing the first one.</p>
<pre><code>var obj = {};

obj.say.hello! = &quot;hola&quot;;

log typeof obj.say;
// stdout: object
log typeof obj.say.hello;
// stdout: string

var obj2 = {};
obj2.list[3]! = 55;

log obj2.toJSON();
// stdout: {&quot;list&quot;: [null, null, null, 55]}
</code></pre></section>
<section>
<h1 id="iterable"> Iterable</h1>
<p>Object, Arrays and Y..X</p>
</section>
<section>
<h1 id="observers"> Observers</h1>
<p>Observers listen changes in variables, it only works on debug mode, on release this code will be removed.</p>
<pre><code>observer(var).on(fn(String action[assignament|access], Mixed value) {...})
</code></pre><section>
<h2 id="functions">1 Functions</h2>
<section>
<h3 id="philosophy">1.1 Philosophy</h3>
<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Function_overloading">Function overloading</a></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Anonymous_function">Anonymous function</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Variadic_function">Variadic function</a></p>
</li>
<li><p>Everything is sent by reference</p>
</li>
<li><p>There is no <code>this</code> concept/keyword.</p>
<p><code>this</code> introduce many memory management problems.</p>
</li>
<li><p><em>Type inference</em>: Argument types are optional (sometimes)</p>
</li>
<li><p><em>Type inference</em>: Return type is optional (sometimes).
If no return statement is found, <code>null</code> will be returned.</p>
</li>
<li><p>if <em>Type inference</em> found two compatible types, compiler will
generate as many functions as needed to optimize execution time.</p>
</li>
<li><p><code>fn</code> is an alias <code>function</code>, for lazy people.</p>
</li>
<li><p>Parenthesis are not required, curly braces are.</p>
</li>
<li><p>A function declaration implicit declare it name and aliases as a type.</p>
</li>
</ul>
</section>
<section>
<h3 id="functions-identifier-name-rules-fn_identifier-">1.2 Functions identifier/name rules (<em>fn_identifier</em>)</h3>
<ul>
<li>Must not be a <a href="#number">number</a>.</li>
<li>Cannot start with a <code>$</code></li>
<li>Any UTF-8 valid character</li>
<li>cannot start with any <a href="#operators">left-to-right operator</a></li>
<li>cannot end with any <a href="#operators">right-to-left operator</a></li>
</ul>
<p>Can I use <code>a+b</code> or <code>a-b</code> as function name... The answer is: <em>Yes</em>, we can. Even snowman!</p>
</section>
<section>
<h3 id="syntax">1.3 Syntax</h3>
<pre><code class="lang-syntax">function-type-declaration
function-header &quot;;&quot;

function-declaration
function-header [&#39;:&#39; type] [&quot;alias&quot; [&#39;,&#39; fn_identifier]+] function-body

function-header
function-header-full
function-header-lazy

function-header-full
(&#39;inline&#39;|&#39;no_inline&#39;)? (&#39;fn&#39;|&#39;function&#39;) &#39;(&#39; fn-identifier arguments-list? &#39;)&#39;

function-header-lazy
(&#39;inline&#39;|&#39;no_inline&#39;)? (&#39;fn&#39;|&#39;function&#39;) fn-identifier arguments-list?

arguments-list
&quot;(&quot;? argument (&#39;,&#39; arguments-list)* &quot;)&quot;?

argument
[type] var_identifier (&#39;=&#39; literal)? ((&#39;!=&#39;|&#39;&lt;&#39;|&#39;&gt;&#39;|&#39;=&gt;&#39;|&#39;&lt;=&#39;) literal)*
function-header-full

function-body
&#39;{&#39; (statement|function-declaration)+ &#39;}&#39;

function-call
fn_identifier &#39;(&#39; parameter-list* &#39;)&#39;
var_identifier &#39;.&#39; fn_identifier &#39;(&#39; parameter-list* &#39;)&#39;

parameter-list
parameter (&#39;,&#39; parameter-list)*

parameter
literal &#39;:&#39; (literal|expression)
(literal|expression) &#39;as&#39; literal
(literal|expression)
</code></pre>
<p>Notice that function-body cannot be empty, there is no
<code>empty-statement</code>.</p>
</section>
<section>
<h3 id="declaration">1.4 Declaration</h3>
<pre><code class="lang-plee">fn giveme x {
    return x;
}

log giveme(0); // stdout: 0
</code></pre>
<p>Declaration implicit declare the type. There is no need to <code>typedef</code> like in c.</p>
<p>Types are automatically exported in modules if required.</p>
</section>
<section>
<h3 id="function-call">1.5 function call</h3>
<ul>
<li><p>Classic function call</p>
<pre><code class="lang-plee">log sum(5, 6);
// stdout 11
</code></pre>
</li>
<li><p>Objects Oriented / Prototypal</p>
<pre><code class="lang-plee">log 5.sum(6);
// stdout 11
</code></pre>
</li>
</ul>
<p><strong>note</strong> If chaning if possible, use the second one, because
allow compiler to use <code>tail-call-recursion</code> that optimize
runtime execution.</p>
<p>To use any of the notation you don&#39;t need to write extra code.</p>
<p>Compiler will expand to the functional form, adding &#39;5&#39; as first
argument.</p>
</section>
<section>
<h3 id="default-arguments">1.6 default arguments</h3>
<pre><code class="lang-plee">fn sum ui8 a, ui8 b = 1 {

}
</code></pre>
<p>You can use other arguments properties as default values.</p>
<pre><code class="lang-plee">fn array arr, ui64 limit = arr.length {

}
</code></pre>
</section>
<section>
<h2 id="argument-assertion-shortcut-">2 Argument assertion (shortcut)</h2>
<p>Assertion is a common use to check arguments invalid ranges/value.</p>
<p>You could use any check comparison to create an assertion.
<em>notice</em>: compiler allow <em>strange</em> checks like &#39;&gt; 5&#39; and &#39;&lt; 6&#39; that
simply don&#39;t allow any number, so becareful.</p>
<pre><code class="lang-plee">// default: 1
// assert if negative
// assert if is null
fn sum ui8 a, ui8 b = 1 &lt; 0 == null {

}
</code></pre>
<section>
<h3 id="parameter-names-call">2.1 Parameter names call</h3>
<p>Name each parameter to match argument names of a function.</p>
<p>Solve two common problems.</p>
<ul>
<li><p>Functions with a lot of parameters, many time with many
optional/default values.</p>
</li>
<li><p>Function overloading with the same types is allowed with diferent
arguments identifiers</p>
</li>
<li><p>Clearly indicate the purpose of each argument you pass to the
function.</p>
</li>
</ul>
<pre><code class="lang-plee">fn sum ui8 a, ui8 b {

}

// and you can define the same function, with different argument names.
fn sum ui8 c, ui8 b {

}

sum(5 as b, 6 as a);
sum(c: 5, b: 6);
sum(5, 6); // compiler-error
// Argument expansion is required found two compatible functions: ...
sum(5, b: 6); // this is allowed
</code></pre>
</section>
<section>
<h3 id="anonimous-functions">2.2 Anonimous functions</h3>
<p>Same syntax prefixing parameters with &quot;,&quot; or use parenthesis.</p>
<pre><code class="lang-plee">fn ,a ,b { // without parenthesis

}

fn (a ,b) { // without parenthesis

}
</code></pre>
</section>
<section>
<h3 id="variadic-function-brackend-dependant-">2.3 Variadic function (brackend-dependant)</h3>
<p>Variadic functions allow you to receive any number of arguments of the same type.</p>
<pre><code class="lang-plee">// this function recieve many ui8
fn sumall ui8... {
    var sum = 0;

    arguments.each({ sum+=$0;})

    return sum;
}

// this is not allowed (atm)
fn glue string start, string to_join..., string end {

}
</code></pre>
</section>
<section>
<h3 id="operator-functions">2.4 Operator functions</h3>
<p><strong>TODO</strong> too vage, need to be more tighten.
this could lead to some problems. operator function declaration
need to be standard, and checked by the compile, define those rules.
<strong>null</strong> as return value?!</p>
<p>Operator function can be used as a shortcut with two purposes:</p>
<ul>
<li>Modify the first argument</li>
<li>Return a new Argument</li>
</ul>
<p>Operator functions doesn&#39;t require <code>.</code> (dot).</p>
<p>Operator list</p>
<ul>
<li>+</li>
<li>-</li>
<li>*</li>
<li>/</li>
<li>=</li>
</ul>
<pre><code class="lang-plee">var vec2 = require(&quot;v2&quot;); // mod type is v2
var va = new vec2(1, 1);
var v_ra = new vec2(1, 1);
var v_rb = new vec2(1, 1);

fn + v2 x, v2 y : null {
    x.x += y.x;
    x.y += y.y;
}

fn + v2 x, v2 y : v2 {
    x.x += y.x + 10;
    x.y += y.y;

    return /*clone */ x;
}
// call first function (no return)
va + va; // v will be modified now (2,2)

// call second function (with return)
v_ra = v_ra + v_rb; // v will be modified now (12,2)
</code></pre>
</section>
<section>
<h3 id="arguments-by-value">2.5 Arguments by value</h3>
<p><code>clone</code> operator is used before an argument to specify that
you want to clone it.</p>
<pre><code class="lang-plee">function mod_all(clone x, y) {
    x = 1;
    y = 1;
}
var x = 0;
var y = 0;
mod_all(x, y);

log x; // stdout: 0
log y; // stdout: 1
</code></pre>
</section>
<section>
<h3 id="-function-as-arguments">2.6 <code>function</code> as arguments</h3>
<p>Any function can be used as argument just using it&#39;s name.
But the <code>fn</code> keyword means that accept any, to accept all in fact you are telling the
parser that duplicate your function as many times as necessary...
like a &quot;C++ template&quot;.</p>
<p>Knowing that a function is divided into header and body... why should you declare
the header of lambda... just don&#39;t. The function header user in the function
declaration will be used.</p>
<pre><code class="lang-plee">// setup

// this function is not callable only declare the type.
fn each_callback($0, string $1);

inline fn each array ar, each_callback callback {
    var i = 0,
        max = ar.lenth;

    for (i = 0; i &lt; max; ++i) {
      callback(ar[i], i);
    }

}

// execution

var arr = [1, 2, 3, 4];

// avoid header on call, default header will be used.
arr.each({
    var value = $0;
    var key = $1;

    log key, &quot;-&quot;, value;
});
// stdout: 1-1
// stdout: 2-2
// stdout: 3-3
// stdout: 4-4
</code></pre>
<p>Compile will expand the call to</p>
<pre><code class="lang-plee">arr.each(fn ($0, string $1) {
  var value = $0;
  var key = $1;

  log key, &quot;-&quot;, value;
});
</code></pre>
</section>
<section>
<h2 id="name-collision-resolution">3 Name collision/resolution</h2>
<p>Because the first argument will have a pseudo-method, functions with the same name
cannot have the same arguments. To avoid collision we introduce a &quot;do not export&quot;</p>
<section>
<h3 id="functions-in-modules-">3.1 functions in modules.</h3>
<p>Just as a brief introduction, functions in modules has special keyword to specify
their behavior.</p>
<ul>
<li><code>export fn</code> allow a function to be used outside the module</li>
<li><code>export fn new</code> constructor of the module</li>
<li><code>export fn delete</code> destructor of the module</li>
</ul>
</section>
<section>
<h3 id="documentation">3.2 documentation</h3>
<p>Documentation is a two-way information for the parser/compiler.</p>
<p>Both sources must be align or one missing.</p>
<p>The following two examples are identical</p>
<pre><code class="lang-plee">/**
* @param ui8 x
* @param ui8 y
*/
fn x, y {

}
</code></pre>
<pre><code class="lang-plee">fn ui8 x, ui8 y {

}
</code></pre>
<p>Misalignment is not permitted.
Even if possible to use both, and merge, it will lead to inconsistency. Just fix it.</p>
<pre><code class="lang-plee-err">/**
* @param ui8 x
* @param ui8 y
*/
fn string x, y {

}
</code></pre>
</section>
<section>
<h3 id="-run">3.3 #run</h3>
<p>Compile time function running.</p>
</section>
<section>
<h3 id="bind-statement">3.4 bind statement</h3>
<p>Bind arguments to a function returning a function with only the missing arguments.</p>
<pre><code class="lang-plee">fn op x, y {
  return x + y * 2;
}

var op_x5 = bind op(5); // same as: bind op(x: 5);
log op_x5(5); // stdout: 15

var op_y5 = bind op(y:5);
log op_y5(1); // stdout: 11
</code></pre>
<p>Arguments cannot be used/bind twice by either a call or bind</p>
<pre><code class="lang-plee-err">fn op x, y {
  return x + y * 2;
}

var op_x5 = bind op(x: 5);

var op_x5_2 = bind op_x5(x: 5); // x parameter not found.
op_x5(x: 5, y: 5); // x parameter not found.
</code></pre>
</section>
<section>
<h3 id="cache-function-">3.5 cache(function)</h3>
<p>Cache the result of a function. Cached value will be returned if the input is the same.</p>
<pre><code class="lang-plee">fn sum x, y {
  log &quot;work&quot;;
  return x + y;
}

var cached_sum = cache(sum);

log cached_sum(5, 5);
log cached_sum(5, 5);
log cached_sum(6, 5);
</code></pre>
<pre><code class="lang-stdout">work
10
10
work
11
</code></pre>
<p><em>Performance note</em>: arguments are serialized and stored as key in an object.
Serialization fetch/store in the object has it costs, so keep in mind that the
function call cost should be greater or no performance gain will be obtained.</p>
</section>
<section>
<h1 id="listeners"> Listeners</h1>
<p>Listeners can be attached to functions at compile time.</p>
<pre><code class="lang-plee">#listener(fn).before(fn(function_name, arguments, stack))
#listener(fn).beforeOff(fn)
#listener(fn).after(fn(function_name, arguments, return_value, error_value, stack))
#listener(fn).afterOff(fn)
#listener(fn).removeAll
</code></pre>
<section>
<h2 id="error-handling">1 Error handling</h2>
<p>Manage exceptions is in plee is very peculiar. Like C, there is not real exceptions class to throw. You throw anything <code>not null</code>.</p>
<p>it&#39;s recomended to use <code>exception()</code> function to throw.</p>
<section>
<h3 id="exception">1.1 exception</h3>
<p><code>exception</code> it&#39;s a reserved word so the compiler can track line and file.
But it should be considered as a function with the following header.</p>
<blockquote>
<p><strong>exception</strong>(<em>string</em> type, <em>string</em> message, <em>ui64</em> code, <em>object</em> user_data) : <em>object</em> {</p>
<p>var object to_throw = {
  &quot;type&quot;: type,
  &quot;message&quot;: message,
  &quot;code&quot;: code,
  &quot;user_data&quot;: user_data,
};</p>
<p> return to_throw;</p>
<p>}</p>
</blockquote>
<pre><code>var err = exception &quot;invalid-auth&quot;, &quot;pwd-failed&quot;, 501;
</code></pre><p><strong>TODO</strong> review, exception needs to be a reserved word ?</p>
</section>
<section>
<h3 id="throw">1.2 throw</h3>
<p>throw a new exception up.</p>
<pre><code>throw &quot;invalid-auth&quot;, &quot;pwd-failed&quot;, 501;
</code></pre></section>
<section>
<h3 id="raise">1.3 raise</h3>
<p><code>raise</code> is a convenient way to throw an exception if a variable is not null.</p>
<pre><code>var exp = null;
raise exp; // do not throw
exp = {&quot;error&quot;: &quot;my message&quot;}
raise exp; // but this will
</code></pre></section>
<section>
<h3 id="manage-an-exception">1.4 manage an exception</h3>
<p><code>exceptions</code> are managed by functions that you can setup at function call.</p>
<p>Exceptions manager are functions with a compatible header:</p>
<ul>
<li>First argument: object</li>
<li>Returns: ui8</li>
</ul>
<p>Returns code behavior.</p>
<ul>
<li>0 (false) exit program with given code</li>
<li>1 (true) continue program execution.
The function will return null and continue.</li>
<li>2 don&#39;t caught &quot;re-throw&quot;</li>
<li>3 retry</li>
</ul>
<pre><code>function manage_error(object err) : ui8 {
  log err.type;
  log err.message;

  return false;
}

function div x, y :i64 {
  return x / y;
}

log div(0, 0) @manage_error;

// stdout: runtime-error
// stdout: division by 0
</code></pre></section>
<section>
<h3 id="error-stack">1.5 error stack</h3>
<p>throw/raise exceptions are good for single exceptions and specific use cases.
For a more general tailor made solution that you can customize use the error
stack functions.</p>
<blockquote>
<p>push_error()</p>
<p>has_error()</p>
<p>pop_error()</p>
<p>error_message()</p>
<p>error_no()</p>
<p>error_list()</p>
</blockquote>
</section>
<section>
<h2 id="if">2 if</h2>
<section>
<h3 id="syntax">2.1 syntax</h3>
<pre><code class="lang-syntax">if-statement
if-header (&#39;else&#39; if-header)* (&#39;else&#39; function-body)?


if-header
&#39;if&#39; expression function-body

if-modifier
&#39;if&#39; expression

unless-modifier
&#39;unless&#39; expression

chained-comparison
(literal|var-declaration) &#39;&lt;&#39; (literal|var-declaration) &#39;&lt;&#39; (literal|var-declaration)
(literal|var-declaration) &#39;&gt;&#39; (literal|var-declaration) &#39;&gt;&#39; (literal|var-declaration)
</code></pre>
</section>
<section>
<h3 id="if-classic">2.2 if-classic</h3>
<pre><code class="lang-plee">if test {
    // note: braces are mandatory, event for empty-statements
} [else if test {

} [else {

}]
</code></pre>
</section>
<section>
<h3 id="if-return">2.3 if-return</h3>
<pre><code class="lang-plee">var x = if test {
  10; // result of the last statement is used.
} else {
  var z = 10 + 7;
  z; // result of the last statement is used.
}
</code></pre>
</section>
<section>
<h3 id="when-if-as-modifier-shortcut-">2.4 when, if as modifier (shortcut)</h3>
<p>Another lazy form to avoid curly braces.</p>
<pre><code class="lang-plee">log &quot;no-curly-braces&quot; when i_am_lazy; // i_am_lazy must be defined :)
</code></pre>
</section>
<section>
<h3 id="unless-as-modifier-shortcut-">2.5 unless as modifier (shortcut)</h3>
<p>For expressiveness this time, because <code>unless</code> is much larger than <code>if !</code>.</p>
<pre><code class="lang-plee">log &quot;this is a small file&quot; unless #line &gt; 500;
</code></pre>
</section>
<section>
<h3 id="chained-comparisons-shortcut-">2.6 Chained Comparisons (shortcut)</h3>
<p>For making it easy to test if a value falls within a certain range.</p>
<pre><code class="lang-plee">if 5 &lt; x &lt; 10 {
    // mad science
}
</code></pre>
</section>
<section>
<h3 id="multiple-and-comparison-shortcut-">2.7 Multiple AND comparison (shortcut)</h3>
<p>To check many things against a single value.</p>
<pre><code class="lang-plee">if x, y, z &lt; 0 { // x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; z &lt; 0
    // mad science
}
</code></pre>
<p><em>STUDY</em> this can cause parsing problems with argument list.</p>
</section>
<section>
<h2 id="switch-case-break-fallthrough-">3 switch (case, break, fallthrough)</h2>
<p>&quot;Switch&quot; statements provide multi-way execution.
An expression or type specifier is compared to the &quot;cases&quot; inside
the &quot;switch&quot; to determine which branch to execute.</p>
<p>Modern languages choose to break by default, and it&#39;s resonable,
they provide <code>fallthrough</code> as error prone replacement of non-<code>break</code>-ing.</p>
<p>In plee both is mandatory to en a case with one of the following.</p>
<ul>
<li><code>break</code>, exit switch</li>
<li><code>fallthrough</code> or <code>next</code>, enter in the next case without testing</li>
<li><code>continue</code>, continue testing</li>
</ul>
<p><code>default</code> case must be the last, and do not need to <code>break</code>, <code>fallthrough</code> or <code>continue</code>.</p>
<p>There are three types of switch:</p>
<ul>
<li>comparison switch.</li>
<li>expression switch.</li>
<li>match-regexp switch.</li>
</ul>
<section>
<h3 id="syntax">3.1 Syntax</h3>
<pre><code class="lang-syntax">switch-statement
**TODO**
</code></pre>
</section>
<section>
<h3 id="comparison-switch">3.2 comparison switch</h3>
<p>Compare all case against one value.</p>
<p>This example illustrate the usage of comparison switch</p>
<pre><code class="lang-plee">fn switch_test(string test) {
  log &quot;switch = &quot;, test;

  switch test {
    case &quot;ok&quot;: // test == &quot;ok&quot;
      log &quot;case ok&quot;;
      continue;

    case &quot;nok&quot;: // test == &quot;nok&quot;
      log &quot;case nok&quot;;
      break;

    case &quot;ok&quot;, &quot;nice&quot;: // test == &quot;ok&quot; || test == &quot;nice&quot;
      log &quot;case ok, nice&quot;;
      break;

    default:
      log &quot;case default&quot;;
  }  
}

switch_test(&quot;ok&quot;);
switch_test(&quot;nok&quot;);
switch_test(&quot;nice&quot;);
switch_test(&quot;unknown&quot;);
</code></pre>
<p>output will be:</p>
<pre><code class="lang-stdout">switch = ok
case ok
case ok, nice
switch = nok
case nok
switch = nice
case ok, nice
switch = unknown
case default
</code></pre>
</section>
<section>
<h3 id="expression-switch-switch-true-">3.3 expression switch (switch true)</h3>
<p>If value is not sent true is used instead.</p>
<pre><code class="lang-plee">switch { // test against true
    default: return &quot;i will be the last&quot;;

    case test == &quot;ok&quot;: // test == &quot;ok&quot;
        echo &quot;ok is found!&quot;;

        // fall thought, but test each case
    case test == &quot;nok&quot;: // test == &quot;nok&quot;
        echo &quot;nok is found!&quot;;
        break; // exit

    case test == &quot;ok&quot; || test == &quot;nice&quot;: // test == &quot;ok&quot; || test == &quot;nice&quot;
        echo &quot;ok or nice is found!&quot;;

        break; // exit
}
</code></pre>
</section>
<section>
<h3 id="match-regexp-switch">3.4 match-regexp switch</h3>
<p>Thre are two variants: values against many regexp, or one regexp against multiple values.</p>
<p>To support regexp the type must have <code>regexp_test</code> function asociation.</p>
<pre><code class="lang-plee">switch v {
  case /a-z/g:
    log &quot;lowercase&quot;;
    break;

  case /A-Z/g:
    log &quot;uppercase&quot;;
    break;
}
</code></pre>
<pre><code class="lang-plee">switch (/0-9/g) {
  case a:
    log &quot;a is a number&quot;;
  break;

  case b:
    log &quot;b is a number&quot;;
  break;
}
</code></pre>
</section>
<section>
<h2 id="for">4 for</h2>
<section>
<h3 id="syntax">4.1 Syntax</h3>
<pre><code class="lang-syntax">for-statement
for-classic function-body for-else?
for-in function-body for-else?
for-in-slice function-body for-else?
for-till function-body for-else?
for-to function-body for-else?
for-iterable function-body for-else?
for-ever function-body for-else?

for-classic
&#39;for&#39; (var-declaration|expression &#39;;&#39;)? expression &#39;;&#39; expression

for-in
&#39;for&#39; (var_identifier &#39;,&#39;)? var_identifier &#39;in&#39; var_identifier

for-in-slice
for-in &#39;[&#39; literal? &#39;:&#39; literal? &#39;]&#39;

for-till
&#39;for&#39; var_identifier &#39;till&#39; (literal|expression)
&#39;for&#39; var-declaration &#39;till&#39; (literal|expression)

for-to
&#39;for&#39; var_identifier &#39;to&#39; (literal|expression)
&#39;for&#39; var-declaration &#39;to&#39; (literal|expression)

for-iterable
&#39;for&#39; var_identifier

for-ever
&#39;for&#39;

for-else
&#39;else&#39; function-body
</code></pre>
</section>
<section>
<h3 id="for-classic">4.2 for-classic</h3>
<pre><code class="lang-plee">
for var i = 0; i &lt; 10; ++i {
    // do your staff
}
</code></pre>
</section>
<section>
<h3 id="for-in">4.3 for-in</h3>
<p>for-in won&#39;t clone the iterable.</p>
<p>To see iterator behavior when remove or push,
see <a href="#array-iterators">array@iterators</a> or
<a href="#object-iterators">object@iterators</a></p>
<p>Iterator :</p>
<ul>
<li>If current value is removed (splice) the next value will have the same key and next value. if end is reached just break.</li>
<li>If a value before the current is removed the next value will have the same key and next value.</li>
<li>If a value after the current is removed won&#39;t appear in the loop.</li>
</ul>
<pre><code class="lang-plee">for [key, ] value in iterable {

} [else {
    // executed if condition fails the first time
}]
</code></pre>
</section>
<section>
<h3 id="for-in-slice">4.4 for-in-slice</h3>
<p>for-in-slice wont clone the iterable part. The iterator will behave if something is removed.</p>
<p>Iterator behavior:</p>
<ul>
<li>If current value is removed (splice) the next value will have the same key and next value.</li>
<li>If a value before the current is removed the next value will have the same key and next value.</li>
<li>If a value after the current is removed won&#39;t appear in the loop.</li>
<li>It will iterate (max - min) times regardless removals or reach iterable.length</li>
</ul>
<pre><code class="lang-plee">for [key, ] value in iterable[3:5] {

} [else {
    // executed if condition fails the first time
}]
</code></pre>
</section>
<section>
<h3 id="for-till-shortcut-">4.5 for-till (shortcut)</h3>
<pre><code class="lang-plee">for variable|number till number {

} [else {
    // executed if condition fails the first time
}]
</code></pre>
<p>Compiler will translate for-till with the folowing rules:</p>
<blockquote>
<p>for i till 10 -&gt; for ; i &lt; 10; ++i</p>
<p>for var i till 10 -&gt; for var i=0; i &lt; 10; ++i</p>
<p>for i=1 till 10 -&gt; for i=1; i &lt; 10; ++i</p>
<p>for var i=1 till 10 -&gt; for var i=1; i &lt; 10; ++i</p>
</blockquote>
</section>
<section>
<h3 id="for-to-shortcut-">4.6 for-to  (shortcut)</h3>
<pre><code class="lang-plee">for variable|number to number {

} [else {
    // executed if condition fails the first time
}]
</code></pre>
<p>Compiler will translate for-to with the folowing rules:</p>
<blockquote>
<p>for i to 10 -&gt; for ; i &lt;= 10; ++i</p>
<p>for var i to 10 -&gt; for var i = 0; i &lt;= 10; ++i</p>
<p>for i=1 to 10 -&gt; for i=1; i &lt;= 10; ++i</p>
<p>for var i=1 to 10 -&gt; for var i=1; i &lt;= 10; ++i</p>
</blockquote>
</section>
<section>
<h3 id="for-iterable-shortcut-">4.7 for-iterable (shortcut)</h3>
<p>for-iterable don&#39;t clone the iterable.</p>
<p>Cannot be nested with the same iterable variable-name. You can alias a variable and nest both for-iterables.</p>
<pre><code class="lang-plee">for iterable {

    // will be aliased, can be used outside the loop!
    assert $0 != iterable.$0;

    // will be aliased, can be used outside the loop!
    assert $1 != iterable.$1;

} [else {
    // executed if condition no length
}]
</code></pre>
<p>Compiler will translate for-iterable with for-in.</p>
</section>
<section>
<h3 id="for-ever">4.8 for-ever</h3>
<pre><code class="lang-plee">for {
  //do something!
}
</code></pre>
</section>
<section>
<h2 id="while">5 while</h2>
<section>
<h3 id="syntax">5.1 Syntax</h3>
<pre><code class="lang-syntax">while-statement
**TODO**
</code></pre>
</section>
<section>
<h3 id="while">5.2 while</h3>
<p>Allows code to be executed repeatedly based on a given boolean condition.</p>
<p>If condition is never else block will be executed if exists.</p>
<pre><code class="lang-plee">while test {
  // block
} [else {
}]
</code></pre>
</section>
<section>
<h2 id="do-while">6 do-while</h2>
<p>Executes a block of code at least once, and then repeatedly executes the block,
or not, depending on a given Boolean condition at the end of the block.</p>
<pre><code class="lang-plee">do {
  // block
} while test;
</code></pre>
</section>
<section>
<h2 id="swap">7 swap</h2>
<p>swap variable names.</p>
<pre><code class="lang-syntax">&#39;swap&#39; var_identifier var_identifier &#39;;&#39;
</code></pre>
<pre><code class="lang-plee">swap x y;
</code></pre>
<p><a name="break"></a></p>
</section>
<section>
<h2 id="break-next-continue">8 break, next, continue</h2>
<section>
<h3 id="syntax">8.1 syntax</h3>
<pre><code class="lang-syntax">break-statement
&#39;break&#39; (literal | number | var-identifier)? &#39;;&#39;

continue-statement
&#39;continue&#39; (literal | number | var-identifier)? &#39;;&#39;

next-statement
&#39;next&#39; (literal | number | var-identifier)? &#39;;&#39;
</code></pre>
</section>
<section>
<h3 id="inside-loops">8.2 Inside loops</h3>
<ul>
<li><p><code>break</code> the nearest loop is immediately terminated and program continue with the next statement to the loop.</p>
</li>
<li><p><code>continue</code> jump to the first available stament:</p>
<ul>
<li>post increment stament (for)</li>
<li>enter condition (for, while)</li>
<li>iteration body (do-while)</li>
</ul>
</li>
<li><p><code>next</code> jump to the iteration body.</p>
</li>
</ul>
<pre><code class="lang-plee">for var i .. 10 {
    break;

    log i;
}
// no stdout
</code></pre>
</section>
<section>
<h3 id="inside-switch">8.3 Inside switch</h3>
<ul>
<li><p><code>break</code> branch to the end of the switch statement</p>
</li>
<li><p><code>continue</code> branch to the next case condition: &quot;continue testing&quot;.</p>
</li>
<li><p><code>next</code> branch to the body of the next case. (<code>fallthrough</code> alias)</p>
</li>
</ul>
</section>
<section>
<h3 id="with-number-as-argument-">8.4 with number as &quot;argument&quot;</h3>
<p>You can specify other than the nearest loop/switch given the statement the number of &quot;jumps up&quot;.</p>
<pre><code class="lang-plee">for var i .. 10 {
    for var j .. 10 {
        break 2; // will break for-i
        log j;
    }
    log i;
}
// no stdout
</code></pre>
</section>
<section>
<h3 id="with-label-as-argument-">8.5 with label as &quot;argument&quot;</h3>
<p>Take as reference the labeled statement, and follow the same rules.</p>
<pre><code class="lang-plee">var found = false;

// ...

break id-label;

id-label: if (found) {
    //
}
</code></pre>
</section>
<section>
<h3 id="iterator-as-argument-shortcut-">8.6 iterator as argument (shortcut)</h3>
<p><code>for-iterator</code> is in fact a label statement by itself.</p>
<pre><code class="lang-plee">for var far_itr in ar {
    for var near_itr in ar {
        break far_itr;
        // will be aliased to break number;
        // no need to count :)
    }
}
</code></pre>
<p>This is because the compiler will label the <code>for</code> for you.</p>
</section>
<section>
<h2 id="repeat">9 repeat</h2>
<p>Repeat allow to <code>repeat</code> nearest loop again from the beginning</p>
<pre><code class="lang-plee">&#39;repeat&#39; (literal)? &#39;;&#39;
</code></pre>
<pre><code class="lang-plee">var i,
    once = false;
for i .. 3 {
    if (!once &amp;&amp; i == 2) {
        once = true;
        repeat;
    }

    log i;
}
// stdout: 0
// stdout: 1
// stdout: 0
// stdout: 1
// stdout: 2
</code></pre>
<p>see <a href="#break">break</a> for the literal options</p>
<section>
<h3 id="defer">9.1 defer</h3>
<p>A <code>defer</code> statement postpone the execution of &quot;something&quot;
until the surrounding function returns or throw.</p>
<pre><code class="lang-syntax">&quot;defer&quot; call-expr
&quot;defer&quot; delete-statement
&quot;defer&quot; log-statement
&quot;defer&quot; assert-statement
&quot;defer&quot; block-statement
</code></pre>
<section>
<h4 id="defer-call-expr">9.1.1 defer call-expr</h4>
<p>Execute function when the surrounding function returns but the deferred call&#39;s arguments are evaluated immediately.</p>
<p><em>Note</em>: to also defer the arguments evaluation you should wrap it in a block-statement.</p>
<pre><code class="lang-plee">defer x(a); // a is evaluated, x will be executed later
defer { x(a); }; // a and x will be evaluated/executed later
</code></pre>
</section>
<section>
<h4 id="defer-delete">9.1.2 defer delete</h4>
<p>free memory when the surrounding function returns or throw/raise.</p>
<pre><code>fn x {
  var x = new ui8[10];
  defer delete x;

  x[0] = 100;
  defer log x;
  log x;
}

x();
</code></pre><pre><code class="lang-stdout">[100]
null
</code></pre>
</section>
<section>
<h4 id="defer-log">9.1.3 defer log</h4>
<p><code>defer log</code> will log the returned value if no arguments are sent.</p>
<pre><code class="lang-plee">fn x {
  var x = &quot;a string!&quot;;
  defer log x;
  defer log;
  return 10;
}
x()
</code></pre>
<pre><code class="lang-stdout">a string!
10
</code></pre>
</section>
<section>
<h4 id="defer-assert">9.1.4 defer assert</h4>
<p><code>defer log</code> will assert retuned value different of null if no arguments are sent.</p>
<pre><code class="lang-plee">fn x {
  defer assert;
  return null;
}
x()
</code></pre>
<pre><code class="lang-stdout">assert returned value must not be null.
</code></pre>
<!--
#### panic

Panic goes along `return` and `raise/throw` as modifier.

```plee
fn reserve target, amount  {
  // some defers calls!

  target = resize ui8[amount];
  defer log "reserved memory";

  if (x > 0) {
    return x; // this is ok
  }
  if (x == 0) {
    panic return x; // this is ok, but there is no reserved memory
  }
  // negative number? obviously resize will fail but it's an example :D
  panic throw "What have you done!";
}
```

There is no recover

-->
<p><a name="with"></a></p>
</section>
<section>
<h2 id="with">10 with</h2>
<pre><code class="lang-syntax">with member-expression (&#39;;&#39; | block-statement)
</code></pre>
<p>continuation of <a href="#struct-example">struct example</a></p>
<pre><code class="lang-plee">var v2 instance;
instance.add(5, 6);
log instance.x; // stdout: 5
log instance.y; // stdout: 6

// you can aboid using &quot;instance&quot; in a block
with instance {
  log x;
  log y;
}

or you can just avoid using &quot;instance&quot; in current scope.
with instance;
</code></pre>
<p>With statement is rather dangerous in other languages.
With statement is like declaring all properties as variables so collisions may
happen and error will raise for clarity and security.</p>
<pre><code class="lang-plee-err">var v2 instance;
var x;

with instance; // error: x is already declared.
log x;
</code></pre>
</section>
<section>
<h2 id="memory-management">11 Memory management</h2>
<section>
<h3 id="new">11.1 new</h3>
<p>Allocate memory.
Memory will be deleted at the end of the block if the variable that own that memory is destroyed.</p>
<pre><code>{
    var x = new ui8[10];
}
// x doesn&#39;t exists, and the memory is freed

{
    var y;
    {
        var x = defer new ui8[10];
        y = x;
    }
    // x doesn&#39;t exists, but the memory ownership is transfered to y
}
// now y is deleted, and memory freed
</code></pre><p>examples:</p>
<pre><code>var ptr_str_10 = new string[10]; // array with 10 strings
var ptr_i_10 = new number[10]; // array with 10 numbers
var ptr_i_10x10 = new number[10][10]; // allocate a 10x10 numeric matrix

var str = new string(10); // string with 10 size, 0 length

var stru_test = new struct_test; // allocate a struct
var blk_test = new block_test(10, 5); // allocate a block with first ptr 10 and second 5
var blk_test_5 = new block_test(10, 5)[5]; // allocate a list of 5
</code></pre></section>
<section>
<h3 id="resize">11.2 resize</h3>
<p>Reallocate memory block.</p>
<pre><code>var x = new string(10); // string with 10 size, 0 length
x = &quot;say hello&quot;;
log x; // stdout: say hello

x = resize string(20); // string with 20 size, 0 length
log x; // stdout: say hello
</code></pre><p>Resize can be used as soft delete when used with 0.
When allocating some structures, like strings it allocate not only the space
for the &quot;string itself&quot; also some numbers, pointers. <code>resize string(0)</code> will
free the pointer while leaving the string to be accesible.</p>
</section>
<section>
<h3 id="delete">11.3 delete</h3>
<p>Free memory.</p>
<pre><code>delete x;
</code></pre></section>
<section>
<h3 id="copy">11.4 copy</h3>
<p>Copy will create a new pointer, allocate the same amount of memory, and copy the memory in it.</p>
<pre><code>
var arr = [];
arr[10] = 100; // arr is resized to 10
arr.splice(2); // arr length = 2

var narr = copy arr;
log narr.length; // stdout: 2
log narr.size; // stdout: 10
log arr.size; // stdout: 10
</code></pre><p>If length is provided to copy, will allocate and copy</p>
<pre><code>
var arr = [];
arr[10] = 100; // arr is resized to 10
arr.splice(2); // arr length = 2

var narr = copy arr[7];
log narr.length; // stdout: 2
log narr.size; // stdout: 7
log arr.size; // stdout: 10
</code></pre></section>
<section>
<h3 id="clone">11.5 clone</h3>
<p>Will allocate and copy the minimum structure needed to replicate the same structure.</p>
<pre><code>
var arr = [];
arr[10] = 100; // arr is resized to 10
arr.splice(2); // arr length = 2

var narr = clone arr;
log narr.length; // stdout: 2
log narr.size; // stdout: 2
log arr.size; // stdout: 10
</code></pre></section>
<section>
<h3 id="avoid-memory-leaks">11.6 avoid memory leaks</h3>
<p>Most of the time, leaks comes when allocating arrays. Array is implement like shared
pointer so when anybody reference it, it will automatically be deleted.</p>
<p><a name="modules"></a></p>
</section>
<section>
<h2 id="modules">12 Modules</h2>
<p>Modules in plee are the way to mimic classes without following any related paradigm.</p>
<section>
<h3 id="module-name-identifier">12.1 Module name/identifier</h3>
<ul>
<li>cannot start with a number.</li>
<li>cannot contains spaces.</li>
<li>cannot contains uppercases.</li>
<li>Cannot start with a $</li>
<li>Any UTF-8 valid character (<strong>STUDY</strong> support only URL-valid character set)</li>
</ul>
</section>
<section>
<h3 id="syntax">12.2 Syntax</h3>
<pre><code class="lang-syntax">module-declaration
&#39;module&#39; module-vars-list &#39;;&#39;

module-vars-list
[&#39;,&#39; module-var]+

module-var
&#39;name&#39; module-name-identifier
&#39;version&#39; string-literal
&#39;tags&#39; string-literal
&#39;description&#39; string-literal
&#39;author&#39; string-literal
&#39;email&#39; string-literal
</code></pre>
<p>Module declaration must be the first statement in a file, only
preceded by a comment.</p>
</section>
<section>
<h3 id="export-functions-and-variables-">12.3 export functions and variables.</h3>
<ul>
<li><code>variable</code></li>
</ul>
<blockquote>
<p>export var secret = &quot;x&quot;;</p>
</blockquote>
<ul>
<li><code>constant</code></li>
</ul>
<blockquote>
<p>export const other_secret = &quot;y&quot;;</p>
</blockquote>
<ul>
<li><code>function</code></li>
</ul>
<blockquote>
<p>export fn get_secret() {}</p>
</blockquote>
</section>
<section>
<h3 id="import-a-module">12.4 import a module</h3>
<pre><code class="lang-syntax">import-statement
&#39;import&#39; import-list? module-name-identifier semver? (&#39;as&#39; var-identifier)?]+

semver
&#39;@&#39; literal

import-list
[&#39;,&#39; (var-identifier|fn-identifier)]
</code></pre>
</section>
<section>
<h3 id="example">12.5 Example</h3>
<p>Definition</p>
<pre><code class="lang-plee">// file: cia.plee
// module must be the first non-comment statement
module name cia,
    version 0.0.1,
    author &quot;John Doe&quot;,
    email &quot;johndoe@johndoe.com&quot;,
    tags &quot;too, many, secrets&quot;;

var hidden = &quot;secret&quot;;

export fn get_secret {
  return hidden;
}

export fn is_safe {
    return true;
}
</code></pre>
<p>Usage:</p>
<pre><code class="lang-plee">// encapsulated, this is the preferred way
import cia@latest as mod_cia;
log mod_cia.get_secret(); // stdout: secret
</code></pre>
<pre><code class="lang-plee">// leaked to current scope, not preferred but accepted for easy to use.
// can cause collisions, in that case you should use encapsulated.
import cia;
log get_secret(); // stdout: secret
</code></pre>
<pre><code class="lang-plee">// partial import encapsulated
import get_secret cia@1.0.0 as mod_b;
log mod_b.get_secret(); // stdout: secret

// some common errors...

log mod_b.is_safe(); // compile-error
// &#39;is_safe&#39; is not imported at line X:Y

log mod_b.undefined_function(); // compile-error
// &#39;undefined_function&#39; is not defined by &#39;cia&#39; module
</code></pre>
<pre><code class="lang-plee">// partial import leaked to current scope
import get_secret cia@0.0.1;
log get_secret(); // stdout: secret

log is_safe();  // compile-error
// &#39;is_safe&#39; is not imported at line X:Y
</code></pre>
</section>
<section>
<h3 id="instance-able-module-class-like-">12.6 instance-able module (class-like)</h3>
<p>As was said, classes are not needed, because modules can be instanced.
<em>modules</em> are a good, plain, simple and also painless to think in classes.</p>
<p>Definition</p>
<pre><code>module wally;

var haystack = &quot;&quot;;

export fn new(clone str) {
    haystack = str;
}

export fn find {
  return haystack.index_of(&#39;wally&#39;);
}
</code></pre><p>Usage:</p>
<pre><code>import wally;

wally.get_secret(); // compile-error
// &#39;wally&#39; require to be instanced with new

var m = new wally(&quot;where is wally&quot;);
log m.find(); // stdout: 9
</code></pre></section>
<section>
<h3 id="special-functions">12.7 Special functions</h3>
<section>
<h4 id="-fn-new-">12.7.1 <code>fn new</code></h4>
<p>  module constructor.</p>
</section>
<section>
<h4 id="-fn-delete-">12.7.2 <code>fn delete</code></h4>
<p>  module destructor.</p>
</section>
<section>
<h4 id="-fn-on_import-">12.7.3 <code>fn on_import</code></h4>
<p>  executed when module is first imported.</p>
</section>
<section>
<h3 id="implementation">12.8 Implementation</h3>
<p><strong>TODO</strong> when backend is defined, we need to review this.</p>
<ul>
<li>Modules name will be used as <em>namespace</em>-like to avoid collisions.</li>
<li>All module-variables will be wrapped into a struct</li>
<li>new/delete function will alloc/delloc the struct</li>
<li>prepend the struct to all functions, declarations and calls.</li>
<li>if new is not defined, the compiler will create a new function
and callit</li>
<li>when instanced, <em>new</em> function is called if exists and instance the struct.</li>
<li>when deleted, <em>delete</em> function is called if exists and destroy the struct.</li>
</ul>
<p><strong>Study</strong></p>
<ul>
<li>if a function does not access to any variable at module-program level,
it could be called outside regardless the module has <em>new</em> or <em>delete</em>.</li>
</ul>
</section>
<section>
<h2 id="embedded-modules">13 Embedded modules</h2>
<p>There are some modules that are embebed into the application.
like <code>call</code>... call function is in fact a module imported in every file.</p>
</section>
<section>
<h1 id="testing"> Testing</h1>
<p>Testing can be done in two stages. Runtime (specific build) and compile time.</p>
<section>
<h2 id="testing-runtime">1 Testing runtime</h2>
<p>Code will be isolated in a specific build. So no testing code will be in the real executable.</p>
<section>
<h3 id="testing-single-function">1.1 Testing single function</h3>
<pre><code class="lang-plee">test return_var[, error_var] fn function_name(arguments...) {
    assert return_var == true &quot;it should be true&quot;;
    assert error_var == null &quot;it should be null&quot;;
}
</code></pre>
</section>
<section>
<h3 id="testing-multiple-functions">1.2 testing multiple functions</h3>
<pre><code class="lang-plee">test fn test_unique_name() {
    //  do your staff, test object will be available for you.
}
</code></pre>
</section>
<section>
<h1 id="testing-asserting-in-compile-time"> testing/asserting in compile time</h1>
<p>If you change <code>test</code> keyword <code>#test</code> the test will be run in compile time.</p>
<p>Same goes to <code>assert</code>, you can use <code>#assert</code>.</p>
<section>
<h2 id="implementation-compiler-">1 Implementation (compiler)</h2>
<p>For compiler builders only.</p>
<section>
<h3 id="abstract-syntax-tree-ast-expansion">1.1 Abstract Syntax Tree (AST) expansion</h3>
<p>Many of the lazy forms introduced in plee are in fact expansions of the current
AST of the program.</p>
<p>For example: <code>for-to</code></p>
<pre><code>for var i to 20 {
  log i;
}
</code></pre><p>This is not meant to be implemented in a low level rather than expanding the
plee code to behave as <code>for-classic</code> so in the end will be compiled as:</p>
<pre><code>for var i=0; i &lt; 20; ++i {
  log i;
}
</code></pre><p><strong>Why?</strong> mainly two reasons:</p>
<ul>
<li>Flexibility</li>
<li>Small subset to implement.</li>
</ul>
<p>So any <strong>shortcut</strong> you could find in plee need to be expanded.</p>
<p>Another good example is implicit header function.</p>
<pre><code>fn callme fn baby(ui8, ui8) {
  return baby(1, 5);
}

// sum 1 and 5
callme({
  return x + y;
});
</code></pre><p>It&#39;s in fact:</p>
<pre><code>callme(fn (ui8, ui8) {
  return x + y;
});
</code></pre><p>BTW: This is a recommendation</p>
</section>
<section>
<h3 id="functions">1.2 functions</h3>
<p>Try expand to its full form (with <em>types</em> and <em>return null</em> if needed).
Complain if something is missing or unknown.</p>
<p>Compiler will also generate multiple versions of the same function
if every type is compatible and <em>no precision would be lost</em>.</p>
<pre><code>fn sum x,  y {
  return x + y;
}
// will be initialy expanded to:
function sum(number x, number y) -&gt; number {
  return x + y;
}
var ui8 x = 5, y = 7;
log sum(5, 7);

// will generate another function with ui8 as inputs and output to optimize run-time execution.
function sum(ui8 x, ui8 y) -&gt; ui8 {
  return x + y;
}
</code></pre><p>Even if a function is not used, must be included because user can <code>call</code> functions by name.</p>
</section>
</body>
</html>
